import { ISortableDOMEvents } from '../dom/event.interfaces';
import { IAnimationState } from '../animation/animation.interfaces';
import { ISortable, ISortableOptions } from './sortable.interfaces';
export declare class Sortable implements ISortable {
    private static defaultOptions;
    private readonly state;
    private readonly instanceId;
    private readonly cleanupManager;
    private animationManager;
    private dragStartTimer?;
    private normalizedGroup;
    options: ISortableOptions;
    el: HTMLElement;
    constructor(el: HTMLElement, options?: Partial<ISortableOptions>);
    private initializeEventListeners;
    private onMove;
    private dispatchMoveEvent;
    private verifyDrag;
    private initDrag;
    private initializeDragOperation;
    private calculateDrag;
    private onDragOver;
    private onScroll;
    private emulateDragOver;
    private onDrop;
    private getTargetSibling;
    private getSortableParent;
    private toggleDraggingElVisibility;
    private appendDraggingEl;
    private createDragElement;
    private positionDragElement;
    private isTouchEvent;
    private isDragEvent;
    private shouldApplyDelay;
    private bindDragListeners;
    private _animate;
    private dispatchSortEvent;
    private getDirection;
    private isOutsideThisEl;
    destroy(): void;
    option<K extends keyof ISortableOptions>(name: K, value?: ISortableOptions[K]): ISortableOptions[K];
    toArray(): string[];
    sort(order: string[], useAnimation?: boolean): void;
    save(): void;
    captureAnimationState(): void;
    addAnimationState(state: IAnimationState): void;
    removeAnimationState(target: HTMLElement): void;
    animateAll(callback?: () => void): void;
    animate(target: HTMLElement, currentRect: DOMRect, toRect: DOMRect, duration: number): void;
    handleDragOver(evt: ISortableDOMEvents): void;
    private getDraggableSelector;
    private prepareGroup;
}
