{"version":3,"file":"index.js","sources":["../src/utils/touch.ts","../src/cleanup.manager.ts","../src/core/state.ts","../src/dom/dom.utils.ts","../src/utils/array.ts","../src/animation/animation.utils.ts","../src/animation/animation.ts","../src/utils/element.ts","../src/utils/scroll.ts","../src/core/sortable.ts"],"sourcesContent":["import { ISortableDOMEvents } from '@/dom/event.interfaces';\nimport { ICoordinates } from '@/global.interfaces';\n\n/**\n * Type guards for event types\n */\nexport function isTouchEvent(evt: Event): evt is TouchEvent {\n  return 'touches' in evt;\n}\n\nexport function isPointerEvent(evt: Event): evt is PointerEvent {\n  return 'pointerType' in evt;\n}\n\n/**\n * Extract touch information from various event types\n * @param evt - Mouse, Touch, or Pointer event\n * @returns Touch object, PointerEvent, or null if no touch data available\n */\nexport function getTouchFromEvent(evt: ISortableDOMEvents): Touch | PointerEvent | null {\n  if (isTouchEvent(evt) && evt.touches[0]) {\n    return evt.touches[0];\n  } else if (isPointerEvent(evt) && evt.pointerType === 'touch') {\n    return evt;\n  }\n  return null;\n}\n\n/**\n * Extract coordinates from any supported event type\n * @param evt - Mouse, Touch, or Pointer event\n * @returns Coordinates object or null if no coordinate data available\n */\nexport function getEventCoordinates(evt: ISortableDOMEvents): ICoordinates | null {\n  const touch = getTouchFromEvent(evt);\n  if (touch) {\n    return {\n      clientX: touch.clientX,\n      clientY: touch.clientY,\n    };\n  }\n\n  // Handle non-touch mouse/pointer events\n  if ('clientX' in evt) {\n    return {\n      clientX: evt.clientX,\n      clientY: evt.clientY,\n    };\n  }\n\n  return null;\n}\n","import { ISortableDOMEventListener } from '@dom/event.interfaces';\n\ninterface ICaptureMode {\n  capture: boolean;\n  passive: boolean;\n}\n\nconst captureMode: ICaptureMode = {\n  capture: false,\n  passive: false,\n};\n\ninterface ICleanupTask {\n  type: 'event' | 'timer' | 'animation' | 'custom';\n  cleanup: () => void;\n}\n\nexport class CleanupManager {\n  private tasks: Map<symbol, Set<ICleanupTask>> = new Map();\n  private static instance: CleanupManager;\n\n  private constructor() {}\n\n  public static getInstance(): CleanupManager {\n    if (!CleanupManager.instance) {\n      CleanupManager.instance = new CleanupManager();\n    }\n    return CleanupManager.instance;\n  }\n\n  private removeEventListener(el: HTMLElement | Document, event: string, fn: ISortableDOMEventListener): void {\n    el.removeEventListener(event, fn as EventListener, captureMode);\n  }\n\n  public registerEventListener(instanceId: symbol, element: HTMLElement | Document, event: string, handler: ISortableDOMEventListener): void {\n    element.addEventListener(event, handler as EventListener, captureMode);\n    this.addTask(instanceId, {\n      type: 'event',\n      cleanup: () => this.removeEventListener(element, event, handler),\n    });\n  }\n\n  public registerTimer(instanceId: symbol, timerId: number): void {\n    this.addTask(instanceId, {\n      type: 'timer',\n      cleanup: () => clearTimeout(timerId),\n    });\n  }\n\n  public registerAnimationCleanup(instanceId: symbol, cleanup: () => void): void {\n    this.addTask(instanceId, {\n      type: 'animation',\n      cleanup,\n    });\n  }\n\n  public registerCustomCleanup(instanceId: symbol, cleanup: () => void): void {\n    this.addTask(instanceId, {\n      type: 'custom',\n      cleanup,\n    });\n  }\n\n  private addTask(instanceId: symbol, task: ICleanupTask): void {\n    if (!this.tasks.has(instanceId)) {\n      this.tasks.set(instanceId, new Set());\n    }\n    this.tasks.get(instanceId)!.add(task);\n  }\n\n  public cleanup(instanceId: symbol): void {\n    const tasks = this.tasks.get(instanceId);\n    if (!tasks) return;\n\n    // Execute all cleanup tasks\n    tasks.forEach((task) => task.cleanup());\n\n    // Clear tasks for this instance\n    this.tasks.delete(instanceId);\n  }\n\n  public cleanupAll(): void {\n    this.tasks.forEach((_tasks: Set<ICleanupTask>, instanceId: symbol) => {\n      this.cleanup(instanceId);\n    });\n    this.tasks.clear();\n  }\n}\n","import { ISortableDOMEvents } from '@/dom/event.interfaces';\nimport { CleanupManager } from '../cleanup.manager';\nimport { getTouchFromEvent } from '../utils/touch';\nimport { ISortable } from './sortable.interfaces';\n\n// Symbol-based instance key\nexport const SORTABLE_INSTANCE_KEY = Symbol('SortableInstance');\n\nexport interface SortableElement extends HTMLElement {\n  [SORTABLE_INSTANCE_KEY]?: ISortable;\n}\n\nexport interface DragState {\n  active: boolean;\n  sourceEl: HTMLElement | null;\n  dragEl: HTMLElement | null;\n  ghostEl: HTMLElement | null;\n  cloneEl: HTMLElement | null;\n  parentEl: HTMLElement | null;\n  nextEl: HTMLElement | null;\n  lastDownEl: HTMLElement | null;\n  oldIndex: number | null;\n  newIndex: number | null;\n  oldDraggableIndex: number | null;\n  newDraggableIndex: number | null;\n  moved: boolean;\n  position: {\n    clientX: number;\n    clientY: number;\n    initialX: number;\n    initialY: number;\n    dx: number;\n    dy: number;\n  };\n}\n\nexport interface GlobalState {\n  activeSortable: ISortable | null;\n  dragOperation: DragState;\n  instances: Map<HTMLElement, ISortable>;\n}\n\ntype StateChangeListener = (state: Readonly<GlobalState>) => void;\n\nexport class SortableState {\n  private static instance: SortableState;\n  private state: GlobalState;\n  private listeners: Set<StateChangeListener> = new Set();\n  private cleanupManager: CleanupManager;\n\n  private constructor() {\n    this.state = {\n      activeSortable: null,\n      instances: new Map(),\n      dragOperation: {\n        active: false,\n        sourceEl: null,\n        dragEl: null,\n        ghostEl: null,\n        cloneEl: null,\n        parentEl: null,\n        nextEl: null,\n        lastDownEl: null,\n        oldIndex: null,\n        newIndex: null,\n        oldDraggableIndex: null,\n        newDraggableIndex: null,\n        moved: false,\n        position: {\n          clientX: 0,\n          clientY: 0,\n          initialX: 0,\n          initialY: 0,\n          dx: 0,\n          dy: 0,\n        },\n      },\n    };\n    this.cleanupManager = CleanupManager.getInstance();\n  }\n\n  public static getInstance(): SortableState {\n    if (!SortableState.instance) {\n      SortableState.instance = new SortableState();\n    }\n    return SortableState.instance;\n  }\n\n  // Enhanced instance management with Symbol-based element binding\n  public registerInstance(el: HTMLElement, instance: ISortable): void {\n    if (this.state.instances.has(el)) {\n      throw new Error('Instance already registered for element');\n    }\n    this.state.instances.set(el, instance);\n    (el as SortableElement)[SORTABLE_INSTANCE_KEY] = instance;\n    this.notifyListeners();\n  }\n\n  public destroyInstance(instanceId: symbol): void {\n    // Execute all cleanup tasks\n    this.cleanupManager.cleanup(instanceId);\n\n    // Find and remove instance from state tracking\n    let elementToRemove: HTMLElement | null = null;\n    this.state.instances.forEach((instance, el) => {\n      if ((instance as any).instanceId === instanceId) {\n        elementToRemove = el;\n      }\n    });\n\n    if (elementToRemove) {\n      this.removeInstance(elementToRemove);\n    }\n  }\n\n  public removeInstance(el: HTMLElement): void {\n    this.state.instances.delete(el);\n    delete (el as SortableElement)[SORTABLE_INSTANCE_KEY];\n    this.notifyListeners();\n  }\n\n  public getInstance(el: HTMLElement): ISortable | undefined {\n    // First try Map-based lookup\n    const instance = this.state.instances.get(el);\n    if (instance) return instance;\n\n    // Fallback to Symbol-based lookup\n    return (el as SortableElement)[SORTABLE_INSTANCE_KEY];\n  }\n\n  // State subscription management\n  public subscribe(listener: StateChangeListener): () => void {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  private notifyListeners(): void {\n    const state = this.getState();\n    this.listeners.forEach((listener) => listener(state));\n  }\n\n  // Immutable state access\n  public getState(): Readonly<GlobalState> {\n    return Object.freeze({ ...this.state });\n  }\n\n  // Drag operation state management\n  public startDrag(sourceEl: HTMLElement, clientX: number = 0, clientY: number = 0): void {\n    if (this.state.dragOperation.active) {\n      throw new Error('Drag operation already in progress');\n    }\n\n    const sortable = this.getInstance(sourceEl);\n    if (!sortable) {\n      throw new Error('No sortable instance found for element');\n    }\n\n    this.state.activeSortable = sortable;\n    this.state.dragOperation = {\n      ...this.state.dragOperation,\n      active: true,\n      sourceEl,\n      oldIndex: this.getElementIndex(sourceEl),\n      position: {\n        clientX,\n        clientY,\n        initialX: clientX,\n        initialY: clientY,\n        dx: 0,\n        dy: 0,\n      },\n    };\n    this.notifyListeners();\n  }\n\n  public updateDragPosition(clientX: number, clientY: number): void {\n    const oldPos = this.state.dragOperation.position;\n    this.state.dragOperation.position = {\n      clientX,\n      clientY,\n      initialX: oldPos.initialX,\n      initialY: oldPos.initialY,\n      dx: clientX - oldPos.clientX,\n      dy: clientY - oldPos.clientY,\n    };\n    this.notifyListeners();\n  }\n\n  public updateDragElements(elements: Partial<Pick<DragState, 'dragEl' | 'ghostEl' | 'cloneEl' | 'parentEl' | 'nextEl' | 'oldIndex' | 'moved'>>): void {\n    this.state.dragOperation = {\n      ...this.state.dragOperation,\n      ...elements,\n    };\n    this.notifyListeners();\n  }\n\n  public endDrag(): void {\n    this.state.activeSortable = null;\n    this.state.dragOperation = {\n      ...this.state.dragOperation,\n      active: false,\n      sourceEl: null,\n      dragEl: null,\n      ghostEl: null,\n      cloneEl: null,\n      oldIndex: null,\n      newIndex: null,\n    };\n    this.notifyListeners();\n  }\n\n  public updateScrollPosition(scrollTop: number, scrollLeft: number): void {\n    // Update scroll position in state\n    this.state.dragOperation.position = {\n      ...this.state.dragOperation.position,\n      dx: this.state.dragOperation.position.dx + scrollLeft,\n      dy: this.state.dragOperation.position.dy + scrollTop,\n    };\n    this.notifyListeners();\n  }\n\n  // Element detection during drag\n  public getElementFromPoint(x: number, y: number): HTMLElement | null {\n    const dragEl = this.state.dragOperation.dragEl;\n    if (dragEl) {\n      const prevDisplay = dragEl.style.display;\n      dragEl.style.display = 'none';\n      const element = document.elementFromPoint(x, y) as HTMLElement | null;\n      dragEl.style.display = prevDisplay;\n      return element;\n    }\n    return document.elementFromPoint(x, y) as HTMLElement | null;\n  }\n\n  // Event target resolution with shadow DOM support\n  public getEventTarget(evt: Event): HTMLElement | null {\n    const { target } = evt;\n    if (!(target instanceof HTMLElement)) return null;\n\n    if (target.shadowRoot) {\n      const touch = getTouchFromEvent(evt as ISortableDOMEvents);\n      if (touch) {\n        const shadowTarget = target.shadowRoot.elementFromPoint(touch.clientX, touch.clientY);\n        if (shadowTarget instanceof HTMLElement) {\n          return shadowTarget;\n        }\n      }\n    }\n\n    return target;\n  }\n\n  // Utility methods\n  private getElementIndex(el: HTMLElement): number {\n    return Array.from(el.parentElement?.children || []).indexOf(el);\n  }\n\n  // Getters for specific state slices\n  public getActiveSortable(): ISortable | null {\n    return this.state.activeSortable;\n  }\n\n  public getDragOperation(): Readonly<DragState> {\n    return Object.freeze({ ...this.state.dragOperation });\n  }\n\n  // Instance validation\n  public hasInstance(el: HTMLElement): boolean {\n    return this.state.instances.has(el) || SORTABLE_INSTANCE_KEY in el;\n  }\n\n  // Debug helper\n  public getInstanceCount(): number {\n    return this.state.instances.size;\n  }\n\n  // Cleanup utility\n  public reset(): void {\n    this.state.instances.forEach((_, el) => this.removeInstance(el));\n    this.endDrag();\n    this.listeners.clear();\n  }\n}\n","import { IMatrix } from '@core/sortable.interfaces';\n\nconst captureMode = {\n  capture: false,\n  passive: false,\n} as const;\n\nexport const addEvent = (el: HTMLElement, event: string, fn: (evt: Event) => void): void => {\n  el.addEventListener(event, fn, captureMode);\n};\n\nexport const removeEvent = (el: HTMLElement, event: string, fn: (evt: Event) => void): void => {\n  el.removeEventListener(event, fn, captureMode);\n};\n\nexport const matches = (el: HTMLElement | null, selector: string): boolean => {\n  if (!selector || !el) return false;\n\n  if (selector[0] === '>') {\n    selector = selector.substring(1);\n  }\n\n  try {\n    return el.matches?.(selector) || false;\n  } catch {\n    return false;\n  }\n};\n\nexport const getParentOrHost = (el: Node): Node => ((el as any).host && el !== document && (el as any).host.nodeType ? (el as any).host : (el.parentNode as Node));\n\nexport const closest = (el: HTMLElement | null, selector: string, ctx: Node = document, includeCTX = false): HTMLElement | null => {\n  if (!el) return null;\n\n  let current: Node | null = el;\n  do {\n    if ((selector != null && (selector[0] === '>' ? current.parentNode === ctx && matches(current as HTMLElement, selector) : matches(current as HTMLElement, selector))) || (includeCTX && current === ctx)) {\n      return current as HTMLElement;\n    }\n\n    if (current === ctx) break;\n  } while ((current = getParentOrHost(current)));\n\n  return null;\n};\n\nexport const toggleClass = (el: HTMLElement, name: string, state: boolean): void => {\n  if (!el || !name) return;\n  el.classList?.[state ? 'add' : 'remove'](name);\n};\n\nexport type CSSProperties = Partial<CSSStyleDeclaration>;\n\nexport const css = (el: HTMLElement, prop: string | CSSProperties, val?: string | number): string | void => {\n  if (!el?.style) return;\n\n  if (typeof prop === 'object') {\n    Object.entries(prop).forEach(([key, value]) => {\n      if (!(key in el.style) && !key.startsWith('webkit')) {\n        key = `-webkit-${key}`;\n      }\n      el.style[key as any] = `${value}${typeof value === 'string' ? '' : 'px'}`;\n    });\n    return;\n  }\n\n  if (val === undefined) {\n    return getComputedStyle(el)[prop as any];\n  }\n\n  if (!(prop in el.style) && !prop.startsWith('webkit')) {\n    prop = `-webkit-${prop}`;\n  }\n\n  el.style[prop as any] = `${val}${typeof val === 'string' ? '' : 'px'}`;\n};\n\nexport const matrix = (el: HTMLElement | string, selfOnly = false): IMatrix | null => {\n  let transforms = '';\n\n  if (typeof el === 'string') {\n    transforms = el;\n  } else {\n    let current: HTMLElement | null = el;\n    do {\n      const transform = css(current, 'transform');\n      if (transform && transform !== 'none') {\n        transforms = `${transform} ${transforms}`;\n      }\n    } while (!selfOnly && (current = current.parentElement));\n  }\n\n  const MatrixConstructor = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n  return MatrixConstructor ? (new MatrixConstructor(transforms) as IMatrix) : null;\n};\n\nexport const getRect = (el: HTMLElement | Window, relativeToContainingBlock = false, relativeToNonStaticParent = false, undoScale = false, container?: HTMLElement): DOMRect => {\n  if (el === window) {\n    return {\n      top: 0,\n      left: 0,\n      bottom: window.innerHeight,\n      right: window.innerWidth,\n      width: window.innerWidth,\n      height: window.innerHeight,\n      x: 0,\n      y: 0,\n      toJSON() {\n        return {\n          x: this.x,\n          y: this.y,\n          top: this.top,\n          right: this.right,\n          bottom: this.bottom,\n          left: this.left,\n          width: this.width,\n          height: this.height,\n        };\n      },\n    } as DOMRect;\n  }\n\n  const elRect = (el as HTMLElement).getBoundingClientRect();\n  let top = elRect.top;\n  let left = elRect.left;\n  let bottom = elRect.bottom;\n  let right = elRect.right;\n  let { width, height } = elRect;\n\n  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n    container = container || ((el as HTMLElement).parentNode as HTMLElement);\n\n    do {\n      if (container?.getBoundingClientRect && (css(container, 'transform') !== 'none' || (relativeToNonStaticParent && css(container, 'position') !== 'static'))) {\n        const containerRect = container.getBoundingClientRect();\n        const borderTop = parseInt(css(container, 'border-top-width') as string) || 0;\n        const borderLeft = parseInt(css(container, 'border-left-width') as string) || 0;\n\n        top -= containerRect.top + borderTop;\n        left -= containerRect.left + borderLeft;\n        bottom = top + elRect.height;\n        right = left + elRect.width;\n        break;\n      }\n    } while ((container = container.parentNode as HTMLElement));\n  }\n\n  if (undoScale && el !== window) {\n    const elMatrix = matrix(container || (el as HTMLElement));\n    if (elMatrix) {\n      const { a: scaleX, d: scaleY } = elMatrix;\n      top /= scaleY;\n      left /= scaleX;\n      width /= scaleX;\n      height /= scaleY;\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top,\n    left,\n    bottom,\n    right,\n    width,\n    height,\n    x: left,\n    y: top,\n    toJSON() {\n      return {\n        x: this.x,\n        y: this.y,\n        top: this.top,\n        right: this.right,\n        bottom: this.bottom,\n        left: this.left,\n        width: this.width,\n        height: this.height,\n      };\n    },\n  } as DOMRect;\n};\n\nexport const getScrollingElement = (): HTMLElement => (document.scrollingElement as HTMLElement) || document.documentElement;\n\nexport const clone = <T extends Node>(el: T): T => el.cloneNode(true) as T;\n","/**\n * Returns the index of an object in an array by matching object properties\n * @param arr Array to search in\n * @param obj Object with properties to match\n * @returns Index of the first matching object, or -1 if not found\n */\nexport function indexOfObject<T extends object>(arr: T[], obj: Partial<T>): number {\n  for (let i = 0; i < arr.length; i++) {\n    const matches = Object.keys(obj).every((key) => {\n      return obj[key as keyof T] === arr[i][key as keyof T];\n    });\n\n    if (matches) return i;\n  }\n  return -1;\n}\n\n/**\n * Moves an item from one position in array to another\n */\nexport function arrayMove<T>(arr: T[], previousIndex: number, newIndex: number): T[] {\n  const array = arr.slice(0);\n  if (newIndex >= array.length) {\n    let k = newIndex - array.length;\n    while (k-- + 1) {\n      array.push(undefined as any);\n    }\n  }\n  array.splice(newIndex, 0, array.splice(previousIndex, 1)[0]);\n  return array;\n}\n\n/**\n * Swaps two elements in an array\n */\nexport function swap<T>(arr: T[], i: number, j: number): void {\n  [arr[i], arr[j]] = [arr[j], arr[i]];\n}\n","import type { ISortableOptions } from '@core/sortable.interfaces';\nimport { css, matrix } from '@dom/dom.utils';\n\n/**\n * Checks if two DOMRects are equal within rounding tolerance\n */\nexport const isRectEqual = (rect1: DOMRect, rect2: DOMRect): boolean => {\n  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n};\n\n/**\n * Calculates the real animation time based on movement distances\n */\nexport const calculateRealTime = (animatingRect: DOMRect, fromRect: DOMRect, toRect: DOMRect, options: ISortableOptions): number => {\n  const dx1 = Math.pow(fromRect.top - animatingRect.top, 2);\n  const dy1 = Math.pow(fromRect.left - animatingRect.left, 2);\n  const dx2 = Math.pow(fromRect.top - toRect.top, 2);\n  const dy2 = Math.pow(fromRect.left - toRect.left, 2);\n\n  return (Math.sqrt(dx1 + dy1) / Math.sqrt(dx2 + dy2)) * (options.animation || 0);\n};\n\n/**\n * Forces a browser repaint by accessing offsetWidth\n */\nexport const forceRepaint = (target: HTMLElement): number => target.offsetWidth;\n\n/**\n * Animate an element from one position to another using transforms\n */\nexport const animate = (target: HTMLElement, currentRect: DOMRect, toRect: DOMRect, duration: number, options: ISortableOptions): void => {\n  if (!duration) return;\n\n  // Clear existing transitions and transforms\n  css(target, 'transition', '');\n  css(target, 'transform', '');\n\n  // Calculate scaling\n  const elMatrix = matrix(target);\n  const scaleX = elMatrix?.a || 1;\n  const scaleY = elMatrix?.d || 1;\n\n  // Calculate translation distances\n  const translateX = (currentRect.left - toRect.left) / scaleX;\n  const translateY = (currentRect.top - toRect.top) / scaleY;\n\n  // Set animation flags\n  target.animatingX = !!translateX;\n  target.animatingY = !!translateY;\n\n  // Apply initial transform\n  css(target, 'transform', `translate3d(${translateX}px,${translateY}px,0)`);\n\n  // Force repaint before transition\n  forceRepaint(target);\n\n  // Start animation\n  css(target, 'transition', `transform ${duration}ms${options.easing ? ' ' + options.easing : ''}`);\n  css(target, 'transform', 'translate3d(0,0,0)');\n\n  // Clear previous animation timeout\n  if (target.animated) {\n    clearTimeout(target.animated as number);\n  }\n\n  // Set cleanup timeout\n  target.animated = window.setTimeout(() => {\n    css(target, 'transition', '');\n    css(target, 'transform', '');\n    target.animated = false;\n    target.animatingX = false;\n    target.animatingY = false;\n  }, duration) as unknown as number;\n};\n","import { ISortable } from '@core/sortable.interfaces';\nimport { SortableState } from '@core/state';\nimport { css, getRect } from '@dom/dom.utils';\nimport { indexOfObject } from '@utils/array';\nimport { CleanupManager } from '../cleanup.manager';\nimport { IAnimationManager, IAnimationState } from './animation.interfaces';\nimport { animate as animateElement, calculateRealTime, isRectEqual } from './animation.utils';\n\n/**\n * Manages animation states and transitions for sortable elements\n */\nexport class AnimationStateManager implements IAnimationManager {\n  private animationStates: IAnimationState[] = [];\n  private animationCallbackId?: number;\n  private sortable: ISortable;\n  private state: SortableState;\n  private cleanupManager: CleanupManager;\n  private instanceId: symbol;\n\n  constructor(sortable: ISortable) {\n    this.sortable = sortable;\n    this.state = SortableState.getInstance();\n    this.cleanupManager = CleanupManager.getInstance();\n    this.instanceId = Symbol('AnimationStateManager');\n  }\n\n  /**\n   * Captures the current state of all animated children\n   */\n  public captureAnimationState(): void {\n    this.animationStates = [];\n    if (!this.sortable.options.animation) return;\n\n    const dragState = this.state.getDragOperation();\n    const children = Array.from(this.sortable.el.children);\n\n    children.forEach((child) => {\n      if (!(child instanceof HTMLElement)) return;\n      if (css(child, 'display') === 'none' || child === dragState.ghostEl) return;\n\n      const state: IAnimationState = {\n        target: child,\n        rect: getRect(child),\n      };\n\n      this.animationStates.push(state);\n\n      // Store original rect for reference\n      const fromRect = { ...state.rect };\n\n      // Compensate for ongoing animations\n      if (child.thisAnimationDuration) {\n        this.compensateForAnimation(child, fromRect);\n      }\n\n      child.fromRect = fromRect;\n    });\n  }\n\n  /**\n   * Adds a new animation state to track\n   */\n  public addAnimationState(state: IAnimationState): void {\n    this.animationStates.push(state);\n  }\n\n  /**\n   * Removes an animation state for a specific target\n   */\n  public removeAnimationState(target: HTMLElement): void {\n    const index = indexOfObject(this.animationStates, { target });\n    if (index !== -1) {\n      this.animationStates.splice(index, 1);\n    }\n  }\n\n  /**\n   * Animates all tracked states\n   */\n  public animateAll(callback?: () => void): void {\n    if (!this.sortable.options.animation) {\n      this.clearAnimation(callback);\n      return;\n    }\n\n    const { animating, maxDuration } = this.processAnimationStates();\n\n    this.scheduleCallback(animating, maxDuration, callback);\n    this.animationStates = [];\n  }\n\n  /**\n   * Animate a single element\n   */\n  public animate(target: HTMLElement, currentRect: DOMRect, toRect: DOMRect, duration: number): void {\n    animateElement(target, currentRect, toRect, duration, this.sortable.options);\n  }\n\n  /**\n   * Compensates for any existing CSS transform matrix by adjusting the position coordinates of a DOMRect.\n   * This is useful when you need the true position of an element ignoring its current transform.\n   * @param element - The HTML element to check for transform matrix\n   * @param rect - The original DOMRect to adjust\n   * @returns A new DOMRect with position adjusted for transform matrix, or the original rect if no transform exists\n   */\n  private compensateForAnimation(element: HTMLElement, rect: DOMRect): DOMRect {\n    const computedMatrix: string = getComputedStyle(element).transform;\n    if (computedMatrix && computedMatrix !== 'none') {\n      const matrix: DOMMatrix = new DOMMatrix(computedMatrix);\n      // Create a mutable copy of the rect properties\n      return new DOMRect(\n        rect.x - matrix.m41, // Adjust x/left\n        rect.y - matrix.m42, // Adjust y/top\n        rect.width,\n        rect.height\n      );\n    }\n    return rect;\n  }\n\n  /**\n   * Process all animation states and calculate timings\n   */\n  private processAnimationStates(): { animating: boolean; maxDuration: number } {\n    let animating = false;\n    let maxDuration = 0;\n\n    this.animationStates.forEach((state) => {\n      const duration = this.calculateAnimationDuration(state);\n      if (duration) {\n        animating = true;\n        maxDuration = Math.max(maxDuration, duration);\n        this.setupAnimationReset(state.target, duration);\n      }\n    });\n\n    return { animating, maxDuration };\n  }\n\n  /**\n   * Calculates the appropriate animation duration for a state transition.\n   * If there's an ongoing animation, it may calculate real-time duration based on previous positions.\n   * Otherwise, it uses the default animation duration from options.\n   *\n   * @param state - The animation state containing target and position information\n   * @returns The calculated animation duration in milliseconds\n   */\n  private calculateAnimationDuration(state: IAnimationState): number {\n    const { target } = state;\n    const currentRect: DOMRect = getRect(target);\n    let duration: number = 0;\n\n    // If there's an ongoing animation, check if we need to calculate real-time duration\n    if (target.thisAnimationDuration && target.prevFromRect && target.prevToRect && isRectEqual(target.prevFromRect, currentRect)) {\n      duration = calculateRealTime(state.rect, target.prevFromRect, target.prevToRect, this.sortable.options);\n    }\n\n    // If the position has changed from the initial position\n    if (target.fromRect && !isRectEqual(currentRect, target.fromRect)) {\n      // Update tracking for the next animation frame\n      this.updateAnimationTracking(target, currentRect);\n\n      // Use default animation duration if real-time duration wasn't calculated\n      if (!duration) {\n        duration = this.sortable.options.animation || 0;\n      }\n\n      this.animate(target, state.rect, currentRect, duration);\n    }\n\n    return duration;\n  }\n\n  /**\n   * Determine if we should calculate real duration based on previous states\n   */\n  // private shouldCalculateRealDuration(target: HTMLElement, currentRect: DOMRect): boolean {\n  //   return target.prevFromRect && target.prevToRect && isRectEqual(target.prevFromRect, currentRect) && !isRectEqual(target.fromRect!, currentRect);\n  // }\n\n  /**\n   * Update animation tracking state for an element\n   */\n  private updateAnimationTracking(target: HTMLElement, currentRect: DOMRect): void {\n    target.prevFromRect = target.fromRect!;\n    target.prevToRect = currentRect;\n  }\n\n  /**\n   * Setup animation reset timer for an element\n   */\n  private setupAnimationReset(target: HTMLElement, duration: number): void {\n    if (target.animationResetTimer) {\n      clearTimeout(target.animationResetTimer);\n    }\n\n    target.animationResetTimer = window.setTimeout(() => {\n      target.animationTime = 0;\n      target.prevFromRect = null;\n      target.fromRect = null;\n      target.prevToRect = null;\n      target.thisAnimationDuration = null;\n      target.animationResetTimer = undefined;\n    }, duration);\n\n    // Register timer for cleanup\n    this.cleanupManager.registerTimer(this.instanceId, target.animationResetTimer);\n    target.thisAnimationDuration = duration;\n  }\n\n  /**\n   * Schedule the animation callback\n   */\n  private scheduleCallback(animating: boolean, duration: number, callback?: () => void): void {\n    if (this.animationCallbackId) {\n      clearTimeout(this.animationCallbackId);\n    }\n\n    if (!animating) {\n      callback?.();\n      return;\n    }\n\n    this.animationCallbackId = window.setTimeout(() => {\n      callback?.();\n      this.animationCallbackId = undefined;\n    }, duration);\n\n    // Register timer for cleanup\n    if (this.animationCallbackId) {\n      this.cleanupManager.registerTimer(this.instanceId, this.animationCallbackId);\n    }\n  }\n\n  /**\n   * Clear animation state and execute callback\n   */\n  private clearAnimation(callback?: () => void): void {\n    clearTimeout(this.animationCallbackId);\n    callback?.();\n  }\n\n  public destroy(): void {\n    // The cleanupManager.cleanup will handle all timer cleanup\n    this.cleanupManager.cleanup(this.instanceId);\n  }\n}\n","import { closest } from '@dom/dom.utils';\n\n/**\n * Generates a unique identifier for an HTML element based on its properties\n * @param element The HTML element to generate an ID for\n * @returns A string hash of the element's properties\n */\nexport function generateElementId(element: HTMLElement): string {\n  // Get element properties safely with type checking\n  const properties: string[] = [element.tagName || '', element.className || '', (element as HTMLImageElement).src || '', (element as HTMLAnchorElement).href || '', element.textContent || ''];\n\n  // Join all properties and generate hash\n  const str = properties.join('_');\n  let hash = 0;\n\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n\n  return Math.abs(hash).toString(36);\n}\n\n/**\n * Gets an array of element IDs from a container based on a draggable selector\n * @param container The container element to search within\n * @param draggableSelector The selector to identify draggable elements\n * @param dataIdAttr The attribute to use for element IDs\n * @returns Array of element IDs\n */\nexport function getElementsArray(container: HTMLElement, draggableSelector: string, dataIdAttr: string): string[] {\n  const order: string[] = [];\n  const children = container.children;\n\n  for (let i = 0; i < children.length; i++) {\n    const el = children[i] as HTMLElement;\n    if (closest(el, draggableSelector, container, false)) {\n      order.push(el.getAttribute(dataIdAttr) || generateElementId(el));\n    }\n  }\n\n  return order;\n}\n","/**\n * Check if an element is scrollable\n */\nexport const isScrollable = (el: HTMLElement): boolean => {\n  const computedStyle = window.getComputedStyle(el);\n  const overflowY = computedStyle.overflowY;\n  const overflowX = computedStyle.overflowX;\n\n  return /auto|scroll|overlay|hidden/.test(overflowY) || /auto|scroll|overlay|hidden/.test(overflowX);\n};\n\n/**\n * Get the closest scrollable parent of an element\n * @param el Element to find scrollable parent for\n * @param includeHidden Whether to include elements with overflow: hidden\n * @returns The closest scrollable parent element or null if none found\n */\nexport const getScrollParent = (el: HTMLElement, includeHidden: boolean = false): HTMLElement | null => {\n  let style: CSSStyleDeclaration;\n\n  // Skip if element is not valid\n  if (!el || !el.parentElement) {\n    return null;\n  }\n\n  let parent: HTMLElement | null = el.parentElement;\n\n  while (parent) {\n    style = window.getComputedStyle(parent);\n    const overflow = style.overflow + style.overflowY + style.overflowX;\n\n    // Check if parent is scrollable\n    if (/auto|scroll|overlay/.test(overflow) || (includeHidden && overflow.includes('hidden'))) {\n      return parent;\n    }\n\n    parent = parent.parentElement;\n  }\n\n  // If no scrollable parent found, return document.scrollingElement or body\n  return (document.scrollingElement as HTMLElement) || document.documentElement;\n};\n\n/**\n * Get all scrolling ancestors of an element\n */\nexport const getScrollingAncestors = (el: HTMLElement): HTMLElement[] => {\n  const ancestors: HTMLElement[] = [];\n  let parent = getScrollParent(el);\n\n  while (parent) {\n    ancestors.push(parent);\n    parent = getScrollParent(parent);\n  }\n\n  return ancestors;\n};\n\n/**\n * Get scroll position of an element\n */\nexport const getScroll = (el: HTMLElement | Window): { scrollTop: number; scrollLeft: number } => {\n  if (el === window) {\n    return {\n      scrollTop: window.pageYOffset || document.documentElement.scrollTop,\n      scrollLeft: window.pageXOffset || document.documentElement.scrollLeft,\n    };\n  }\n\n  return {\n    scrollTop: (el as HTMLElement).scrollTop,\n    scrollLeft: (el as HTMLElement).scrollLeft,\n  };\n};\n","import { ISortableDOMEventListener, ISortableDOMEvents } from '@/dom/event.interfaces';\nimport { getEventCoordinates, getTouchFromEvent } from '@/utils/touch';\nimport { AnimationStateManager } from '@animation/animation';\nimport { IAnimationState } from '@animation/animation.interfaces';\nimport { ISortable, ISortableGroup, ISortableOptions, SortableDirection } from '@core/sortable.interfaces';\nimport { closest, css, getRect, matrix, toggleClass } from '@dom/dom.utils';\nimport { getElementsArray } from '@utils/element';\nimport { getScroll, getScrollParent } from '@utils/scroll';\nimport { CleanupManager } from '../cleanup.manager';\nimport { DragState, SortableState } from './state';\n\nexport class Sortable implements ISortable {\n  private static defaultOptions: ISortableOptions = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: '>*',\n    swapThreshold: 1,\n    invertSwap: false,\n    invertedSwapThreshold: null,\n    removeCloneOnHide: true,\n    direction: 'vertical',\n    draggingClass: 'sortable-dragging',\n    chosenClass: 'sortable-chosen',\n    dragClass: 'sortable-drag',\n    ignore: 'a, img',\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function (dataTransfer: DataTransfer, activeEl: HTMLElement) {\n      dataTransfer.setData('Text', activeEl.textContent || '');\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: 'data-id',\n    delay: 0,\n    touchStartThreshold: 1,\n    forceFallback: false,\n    fallbackClass: 'sortable-fallback',\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: { x: 0, y: 0 },\n    supportPointer: true,\n    emptyInsertThreshold: 5,\n  };\n\n  private readonly state: SortableState;\n  private readonly instanceId: symbol;\n  private readonly cleanupManager: CleanupManager;\n  private animationManager: AnimationStateManager;\n  private dragStartTimer?: number;\n  private normalizedGroup: ISortableGroup | null = null;\n\n  public options: ISortableOptions;\n  public el: HTMLElement;\n\n  constructor(el: HTMLElement, options?: Partial<ISortableOptions>) {\n    if (!el || !el.nodeType || el.nodeType !== 1) {\n      throw new Error('Sortable: `el` must be HTMLElement, not null or undefined');\n    }\n\n    this.instanceId = Symbol('SortableInstance');\n    this.cleanupManager = CleanupManager.getInstance();\n    this.el = el;\n    this.options = { ...Sortable.defaultOptions, ...options };\n    this.state = SortableState.getInstance();\n\n    // Initialize animation manager with cleanup\n    this.animationManager = new AnimationStateManager(this);\n    this.cleanupManager.registerAnimationCleanup(this.instanceId, () => {\n      this.animationManager.destroy();\n    });\n\n    // Register this instance in state\n    this.state.registerInstance(el, this);\n\n    // Initialize event listeners\n    this.initializeEventListeners();\n\n    // Prepare group options if specified\n    if (this.options.group) {\n      this.prepareGroup();\n    }\n  }\n\n  private initializeEventListeners(): void {\n    const verifyDragHandler: ISortableDOMEventListener = (evt: ISortableDOMEvents): void => {\n      this.verifyDrag(evt);\n    };\n\n    // Register main event listeners\n    if (this.options.supportPointer) {\n      this.cleanupManager.registerEventListener(this.instanceId, this.el, 'pointerdown', verifyDragHandler);\n    } else {\n      this.cleanupManager.registerEventListener(this.instanceId, this.el, 'mousedown', verifyDragHandler);\n      this.cleanupManager.registerEventListener(this.instanceId, this.el, 'touchstart', verifyDragHandler);\n    }\n\n    // Register scroll listeners if needed\n    const scrollEl = getScrollParent(this.el);\n    if (scrollEl && scrollEl !== document.documentElement && scrollEl !== document.scrollingElement) {\n      const scrollHandler: ISortableDOMEventListener = (evt: ISortableDOMEvents): void => {\n        this.onScroll(evt);\n      };\n\n      this.cleanupManager.registerEventListener(this.instanceId, scrollEl, 'scroll', scrollHandler);\n    }\n  }\n\n  // Helper method that calculates if elements should be swapped based on movement\n  private onMove = (dragRect: DOMRect, targetRect: DOMRect, direction: SortableDirection, sibling: HTMLElement | null): boolean => {\n    const options = this.options;\n    const threshold = options.swapThreshold || 1;\n    const invertSwap = options.invertSwap || false;\n    const invertedThreshold = options.invertedSwapThreshold || threshold;\n\n    const after = invertSwap ? !invertedThreshold : threshold > 0.5;\n    const dragState = this.state.getDragOperation();\n\n    if (direction === 'vertical') {\n      const dragCenter = dragRect.top + dragRect.height / 2;\n      const targetCenter = targetRect.top + targetRect.height / 2;\n      const isOverThreshold = after ? (dragCenter - targetCenter) / targetRect.height > threshold : (targetCenter - dragCenter) / targetRect.height > invertedThreshold;\n\n      if (isOverThreshold) {\n        return this.dispatchMoveEvent(sibling, dragState.sourceEl, after);\n      }\n    } else {\n      const dragCenter = dragRect.left + dragRect.width / 2;\n      const targetCenter = targetRect.left + targetRect.width / 2;\n      const isOverThreshold = after ? (dragCenter - targetCenter) / targetRect.width > threshold : (targetCenter - dragCenter) / targetRect.width > invertedThreshold;\n\n      if (isOverThreshold) {\n        return this.dispatchMoveEvent(sibling, dragState.sourceEl, after);\n      }\n    }\n\n    return false;\n  };\n\n  private dispatchMoveEvent(target: HTMLElement | null, related: HTMLElement | null, willInsertAfter: boolean): boolean {\n    if (!target || !related) return false;\n\n    const moveEvent = new CustomEvent('sortable:move', {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        target,\n        related,\n        willInsertAfter,\n      },\n    });\n\n    this.el.dispatchEvent(moveEvent);\n    return !moveEvent.defaultPrevented;\n  }\n\n  // initial event handler: triggers when a user first interacts with a sortable element\n  private verifyDrag = (evt: ISortableDOMEvents): void => {\n    if (!evt.cancelable) return;\n\n    const target = this.state.getEventTarget(evt);\n    if (!target) return;\n\n    const validTarget = closest(target, this.getDraggableSelector(), this.el, false);\n    if (!validTarget) return;\n\n    // Get initial position from event\n    const coordinates = getEventCoordinates(evt);\n    if (!coordinates) return;\n\n    const { clientX, clientY } = coordinates;\n\n    // Start drag operation in state with initial position\n    this.state.startDrag(validTarget, clientX, clientY);\n\n    // Initialize drag position\n    const touch = getTouchFromEvent(evt);\n    if (touch) {\n      this.state.updateDragPosition(touch.clientX, touch.clientY);\n    }\n\n    this.initializeDragOperation(touch, validTarget);\n  };\n\n  private initDrag = () => {\n    const dragState = this.state.getDragOperation();\n    if (!dragState.sourceEl) return;\n\n    // Create preview\n    this.appendDraggingEl();\n\n    // Setup document listeners\n    const ownerDocument = this.el.ownerDocument;\n    if (this.options.supportPointer) {\n      this.cleanupManager.registerEventListener(this.instanceId, ownerDocument, 'pointermove', this.calculateDrag as EventListener);\n    } else {\n      this.cleanupManager.registerEventListener(this.instanceId, ownerDocument, 'mousemove', this.calculateDrag as EventListener);\n      this.cleanupManager.registerEventListener(this.instanceId, ownerDocument, 'touchmove', this.calculateDrag as EventListener);\n    }\n    this.cleanupManager.registerEventListener(this.instanceId, ownerDocument, 'dragover', this.onDragOver as EventListener);\n\n    // Update state and dispatch\n    this.state.updateDragElements({\n      dragEl: dragState.sourceEl,\n      oldIndex: Array.from(this.el.children).indexOf(dragState.sourceEl),\n    });\n    this.dispatchSortEvent('dragstart');\n  };\n\n  private initializeDragOperation(touch: Touch | PointerEvent | null, target: HTMLElement): void {\n    target.style.willChange = 'transform';\n    this.bindDragListeners(!!touch);\n\n    // Handle delay if needed\n    const delay = (this.options as ISortableOptions).delay;\n\n    if (this.shouldApplyDelay()) {\n      this.dragStartTimer = window.setTimeout(() => {\n        this.initDrag();\n        this.dragStartTimer = undefined;\n      }, delay);\n\n      // Register timer cleanup\n      this.cleanupManager.registerTimer(this.instanceId, this.dragStartTimer);\n    } else {\n      this.initDrag();\n    }\n  }\n\n  // Swap calculation logic: Tracks the dragging element\n  private calculateDrag = (evt: ISortableDOMEvents): void => {\n    const dragState = this.state.getDragOperation();\n    if (!dragState.active || !evt.cancelable) return;\n\n    const coordinates = getEventCoordinates(evt);\n    if (!coordinates) return;\n\n    const { clientX, clientY } = coordinates;\n\n    // Update position in state\n    this.state.updateDragPosition(clientX, clientY);\n\n    if (dragState.dragEl) {\n      evt.preventDefault();\n      this.emulateDragOver(evt);\n\n      // Update preview position\n      const mtx = matrix(dragState.dragEl) || { e: 0, f: 0 };\n      const dx = clientX - dragState.position.clientX;\n      const dy = clientY - dragState.position.clientY;\n\n      dragState.dragEl.style.transform = `translate3d(${dx + (mtx.e || 0)}px,${dy + (mtx.f || 0)}px,0)`;\n    } else if (!dragState.moved) {\n      const threshold = (this.options as ISortableOptions).touchStartThreshold || 1;\n      const moveDistance = Math.max(Math.abs(clientX - dragState.position.clientX), Math.abs(clientY - dragState.position.clientY));\n\n      if (moveDistance >= threshold) {\n        this.state.updateDragElements({ moved: true });\n        this.initDrag();\n      }\n    }\n  };\n\n  private onDragOver = (evt: ISortableDOMEvents): void => {\n    const dragState = this.state.getDragOperation();\n    if (!dragState.active || !dragState.sourceEl) return;\n\n    evt.preventDefault();\n    evt.stopPropagation();\n\n    let clientX: number;\n    let clientY: number;\n\n    // Extract coordinates based on event type\n    if (this.isTouchEvent(evt)) {\n      const touch = evt.touches[0];\n      if (!touch) return;\n      clientX = touch.clientX;\n      clientY = touch.clientY;\n    } else if (this.isDragEvent(evt)) {\n      clientX = evt.clientX;\n      clientY = evt.clientY;\n    } else {\n      // MouseEvent\n      clientX = evt.clientX;\n      clientY = evt.clientY;\n    }\n\n    const targetEl = document.elementFromPoint(clientX, clientY) as HTMLElement | null;\n    if (!targetEl) return;\n\n    const validTarget = closest(targetEl, this.getDraggableSelector(), this.el, false);\n    if (!validTarget || validTarget === dragState.sourceEl) return;\n\n    const rect = getRect(validTarget);\n    const direction = this.getDirection(evt, validTarget);\n\n    // Calculate previous and next siblings for potential swapping\n    const prevSibling = validTarget.previousElementSibling as HTMLElement | null;\n    const nextSibling = validTarget.nextElementSibling as HTMLElement | null;\n\n    // Calculate insertion point based on direction and position\n    const centerY = rect.top + rect.height / 2;\n    const centerX = rect.left + rect.width / 2;\n    const isVertical = direction === 'vertical';\n    const coordinate = isVertical ? clientY : clientX;\n    const center = isVertical ? centerY : centerX;\n\n    // Determine if we should insert before or after the target\n    const insertBefore = coordinate < center;\n    const sibling = insertBefore ? prevSibling : nextSibling;\n\n    // Get drag element rect for comparison\n    const dragRect = getRect(dragState.sourceEl);\n\n    // Check if we should move the element\n    if (this.onMove(dragRect, rect, direction, sibling)) {\n      // Capture the current state for animation\n      this.captureAnimationState();\n\n      // Insert the dragged element\n      if (insertBefore) {\n        validTarget.parentNode?.insertBefore(dragState.sourceEl, validTarget);\n      } else {\n        validTarget.parentNode?.insertBefore(dragState.sourceEl, validTarget.nextSibling);\n      }\n\n      // Add animation state for the moved target\n      this.addAnimationState({\n        target: validTarget,\n        rect: getRect(validTarget),\n      });\n\n      // Update drag state with new position\n      this.state.updateDragPosition(clientX, clientY);\n\n      // Dispatch sort event if needed\n      const oldIndex = dragState.oldIndex ?? -1;\n      const newIndex = Array.from(this.el.children).indexOf(dragState.sourceEl);\n\n      if (oldIndex !== newIndex) {\n        this.dispatchSortEvent('sort', {\n          oldIndex,\n          newIndex,\n          dragEl: dragState.sourceEl,\n          target: validTarget,\n        });\n      }\n\n      // Animate elements if animation duration is set\n      if ((this.options as ISortableOptions).animation) {\n        this.animateAll();\n      }\n    }\n  };\n\n  private onScroll = (evt: ISortableDOMEvents): void => {\n    const dragState = this.state.getDragOperation();\n    if (!dragState.active || !dragState.dragEl) return;\n\n    // Get scroll coordinates\n    const { scrollTop, scrollLeft } = evt.target as HTMLElement;\n\n    // Update drag element position based on scroll\n    const mtx = matrix(dragState.dragEl) || { e: 0, f: 0 };\n    const dx = dragState.position.clientX - dragState.position.initialX;\n    const dy = dragState.position.clientY - dragState.position.initialY;\n\n    dragState.dragEl.style.transform = `translate3d(${dx + (mtx.e || 0)}px,${dy + (mtx.f || 0)}px,0)`;\n\n    // Update scroll position in state\n    this.state.updateScrollPosition(scrollTop, scrollLeft);\n  };\n\n  private emulateDragOver = (evt: ISortableDOMEvents): void => {\n    // 1. Validate drag state\n    const dragState = this.state.getDragOperation();\n    if (!dragState.active || !dragState.dragEl) return;\n\n    // 2. Get coordinates from event\n    const coordinates = getEventCoordinates(evt);\n    if (!coordinates) return;\n\n    const { clientX, clientY } = coordinates;\n\n    // 3. Handle drag preview visibility\n    this.toggleDraggingElVisibility(false);\n\n    // 4. Find target element at point\n    const targetAtPoint = document.elementFromPoint(clientX, clientY);\n    if (!targetAtPoint || !(targetAtPoint instanceof HTMLElement)) {\n      this.toggleDraggingElVisibility(true);\n      return;\n    }\n\n    // 5. Show drag preview\n    this.toggleDraggingElVisibility(true);\n\n    // 6. Handle dragging outside current sortable\n    if (this.isOutsideThisEl(targetAtPoint)) {\n      const targetSortable = this.getSortableParent(targetAtPoint);\n      if (targetSortable && targetSortable !== this) {\n        targetSortable.handleDragOver(evt);\n        return;\n      }\n    }\n\n    // 7. Get valid drag target\n    const validTarget = closest(targetAtPoint, this.getDraggableSelector(), this.el, false);\n    if (!validTarget || validTarget === dragState.sourceEl) return;\n\n    // 8. Calculate rects and direction\n    const dragRect = getRect(dragState.dragEl);\n    const targetRect = getRect(validTarget);\n    const direction = this.getDirection(evt, validTarget);\n\n    // 9. Determine sibling based on direction\n    const sibling = this.getTargetSibling(validTarget, direction);\n\n    // 10. Check if move is valid and perform animation\n    if (this.onMove(dragRect, targetRect, direction, sibling)) {\n      this.captureAnimationState();\n      this._animate(validTarget);\n      this.addAnimationState({\n        target: validTarget,\n        rect: getRect(validTarget),\n      });\n    }\n  };\n\n  private onDrop = (evt: Event): void => {\n    if (evt) {\n      evt.preventDefault();\n    }\n\n    const dragState = this.state.getDragOperation();\n    if (!dragState.active || !dragState.dragEl) return;\n\n    // Remove preview\n    if (dragState.dragEl.parentNode) {\n      dragState.dragEl.parentNode.removeChild(dragState.dragEl);\n    }\n\n    // Reset styles\n    const draggingClass = (this.options as ISortableOptions).draggingClass || 'sortable-dragging';\n    const fallbackClass = (this.options as ISortableOptions).fallbackClass || 'sortable-fallback';\n\n    if (dragState.sourceEl) {\n      toggleClass(dragState.sourceEl, draggingClass, false);\n      toggleClass(dragState.sourceEl, fallbackClass, false);\n    }\n\n    // Dispatch drop event\n    this.dispatchSortEvent('drop');\n\n    // Reset state\n    this.state.endDrag();\n  };\n\n  // Helper method to determine target sibling\n  private getTargetSibling(target: HTMLElement, direction: SortableDirection): HTMLElement | null {\n    return direction === 'vertical' ? (target.nextElementSibling as HTMLElement | null) : (target.previousElementSibling as HTMLElement | null);\n  }\n\n  private getSortableParent = (el: HTMLElement): ISortable | null => {\n    let current: HTMLElement | null = el;\n\n    while (current && current !== document.body) {\n      const instance = this.state.getInstance(current);\n      if (instance) return instance;\n      current = current.parentElement;\n    }\n\n    return null;\n  };\n\n  private toggleDraggingElVisibility(show: boolean): void {\n    const dragState = this.state.getDragOperation();\n    if (dragState.dragEl) {\n      css(dragState.dragEl, 'display', show ? '' : 'none');\n    }\n  }\n\n  private appendDraggingEl(): void {\n    const dragState: Readonly<DragState> = this.state.getDragOperation();\n    if (!dragState.sourceEl) return;\n\n    // Early container resolution\n    const container: HTMLElement = (this.options as ISortableOptions).fallbackOnBody ? document.body : this.el;\n    const scrollParent: HTMLElement | null = getScrollParent(this.el);\n    const isAbsolutePositioning: boolean = (scrollParent && scrollParent !== document.body) ?? false;\n\n    // Get initial rect with proper parameters\n    const rect: DOMRect = getRect(dragState.sourceEl, true, (this.options as ISortableOptions).fallbackOnBody, true, container);\n\n    // Create drag element with all properties\n    const dragEl: HTMLElement = this.createDragElement(dragState.sourceEl, rect);\n\n    // Position the element\n    this.positionDragElement(dragEl, rect, isAbsolutePositioning, scrollParent);\n\n    // Append and update state\n    container.appendChild(dragEl);\n    this.state.updateDragElements({ dragEl });\n  }\n\n  private createDragElement(sourceEl: HTMLElement, rect: DOMRect): HTMLElement {\n    const dragEl: HTMLElement = sourceEl.cloneNode(true) as HTMLElement;\n    const { draggingClass = 'sortable-dragging', fallbackClass = 'sortable-fallback' } = this.options;\n\n    // Add classes\n    toggleClass(dragEl, fallbackClass, true);\n    toggleClass(dragEl, draggingClass, true);\n\n    // Apply base styles\n    const baseStyles: Record<string, string> = {\n      position: 'fixed',\n      zIndex: '100000',\n      pointerEvents: 'none',\n      width: `${rect.width}px`,\n      height: `${rect.height}px`,\n      boxSizing: 'border-box',\n      margin: '0',\n      opacity: '0.8',\n      transition: '',\n      transform: '',\n    };\n\n    css(dragEl, baseStyles);\n    return dragEl;\n  }\n\n  private positionDragElement(dragEl: HTMLElement, rect: DOMRect, isAbsolutePositioning: boolean, scrollParent: HTMLElement | null): void {\n    if (!isAbsolutePositioning) {\n      css(dragEl, {\n        top: `${rect.top}px`,\n        left: `${rect.left}px`,\n      });\n      return;\n    }\n\n    // Handle scroll parent positioning\n    const scrollParentRect: DOMRect = getRect(scrollParent!);\n    const scroll: { scrollTop: number; scrollLeft: number } = getScroll(scrollParent!);\n\n    css(dragEl, {\n      position: 'absolute',\n      top: `${rect.top - scrollParentRect.top + scroll.scrollTop}px`,\n      left: `${rect.left - scrollParentRect.left + scroll.scrollLeft}px`,\n    });\n  }\n\n  // Type guards for event types\n  private isTouchEvent(evt: Event): evt is TouchEvent {\n    return 'touches' in evt;\n  }\n\n  private isDragEvent(evt: Event): evt is DragEvent {\n    return 'dataTransfer' in evt;\n  }\n\n  private shouldApplyDelay(): boolean {\n    return !!(this.options.delay && this.options.delay > 0);\n  }\n\n  private bindDragListeners(isTouch: boolean): void {\n    const doc = this.el.ownerDocument;\n\n    if ((this.options as ISortableOptions).supportPointer) {\n      this.cleanupManager.registerEventListener(this.instanceId, doc, 'pointermove', this.calculateDrag as EventListener);\n      this.cleanupManager.registerEventListener(this.instanceId, doc, 'pointerup', this.onDrop as EventListener);\n      this.cleanupManager.registerEventListener(this.instanceId, doc, 'pointercancel', this.onDrop as EventListener);\n    } else {\n      this.cleanupManager.registerEventListener(this.instanceId, doc, isTouch ? 'touchmove' : 'mousemove', this.calculateDrag as EventListener);\n      this.cleanupManager.registerEventListener(this.instanceId, doc, isTouch ? 'touchend' : 'mouseup', this.onDrop as EventListener);\n      if (isTouch) {\n        this.cleanupManager.registerEventListener(this.instanceId, doc, 'touchcancel', this.onDrop as EventListener);\n      }\n    }\n  }\n\n  private _animate(target: HTMLElement): void {\n    const dragState = this.state.getDragOperation();\n    if (!dragState.sourceEl) return;\n\n    const oldIndex = Array.from(this.el.children).indexOf(dragState.sourceEl);\n    const newIndex = Array.from(this.el.children).indexOf(target);\n\n    if (oldIndex !== newIndex) {\n      this.el.insertBefore(dragState.sourceEl, target);\n      this.dispatchSortEvent('sort', {\n        oldIndex,\n        newIndex,\n        dragEl: dragState.sourceEl,\n        target,\n      });\n    }\n  }\n\n  private dispatchSortEvent(name: string, detail: Record<string, any> = {}): void {\n    const evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        ...detail,\n        from: this.el,\n      },\n    });\n\n    this.el.dispatchEvent(evt);\n  }\n\n  private getDirection(evt: Event, target: HTMLElement): SortableDirection {\n    const direction = this.options.direction;\n    if (typeof direction === 'function') {\n      return direction.call(this, evt, target, this.state.getDragOperation().sourceEl);\n    }\n    return direction || 'vertical';\n  }\n\n  private isOutsideThisEl(target: HTMLElement | null): boolean {\n    return !target || (!this.el.contains(target) && target !== this.el);\n  }\n\n  public destroy(): void {\n    this.state.destroyInstance(this.instanceId);\n  }\n\n  public option<K extends keyof ISortableOptions>(name: K, value?: ISortableOptions[K]): ISortableOptions[K] {\n    if (value === undefined) {\n      return this.options[name];\n    }\n\n    this.options[name] = value;\n    if (name === 'group') {\n      this.prepareGroup();\n    }\n    return value;\n  }\n\n  public toArray(): string[] {\n    return getElementsArray(this.el, this.getDraggableSelector(), (this.options as ISortableOptions).dataIdAttr || 'data-id');\n  }\n\n  public sort(order: string[], useAnimation?: boolean): void {\n    const items: { [key: string]: HTMLElement } = {};\n    const rootEl = this.el;\n\n    this.toArray().forEach((id, i) => {\n      const el = rootEl.children[i] as HTMLElement;\n      if (closest(el, this.getDraggableSelector(), rootEl, false)) {\n        items[id] = el;\n      }\n    });\n\n    useAnimation && this.captureAnimationState();\n\n    order.forEach((id) => {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n\n    useAnimation && this.animateAll();\n  }\n\n  // unused so far\n  public save(): void {\n    const store = (this.options as ISortableOptions).store;\n    store?.set?.(this);\n  }\n\n  // Animation Methods\n  public captureAnimationState(): void {\n    this.animationManager.captureAnimationState();\n  }\n\n  public addAnimationState(state: IAnimationState): void {\n    this.animationManager.addAnimationState(state);\n  }\n\n  public removeAnimationState(target: HTMLElement): void {\n    this.animationManager.removeAnimationState(target);\n  }\n\n  public animateAll(callback?: () => void): void {\n    this.animationManager.animateAll(callback);\n  }\n\n  public animate(target: HTMLElement, currentRect: DOMRect, toRect: DOMRect, duration: number): void {\n    this.animationManager.animate(target, currentRect, toRect, duration);\n  }\n\n  public handleDragOver(evt: ISortableDOMEvents): void {\n    this.onDragOver(evt);\n  }\n\n  private getDraggableSelector(): string {\n    return (this.options as ISortableOptions).draggable;\n  }\n\n  private prepareGroup(): void {\n    const options = this.options;\n\n    if (!options.group) {\n      options.group = {\n        name: undefined,\n        pull: true,\n        put: true,\n        revertClone: false,\n      };\n    }\n\n    if (typeof options.group === 'string') {\n      options.group = { name: options.group };\n    }\n\n    const group = options.group as {\n      name?: string;\n      pull?: boolean | 'clone' | ((to: ISortable, from: ISortable, dragEl: HTMLElement, event: Event) => boolean);\n      put?: boolean | string[] | ((to: ISortable, from: ISortable, dragEl: HTMLElement, event: Event) => boolean);\n      revertClone?: boolean;\n    };\n\n    this.normalizedGroup = {\n      name: group.name ?? null,\n      checkPull: (to: ISortable, from: ISortable, dragEl: HTMLElement, evt: Event): boolean | 'clone' => {\n        if (!group.pull) return false;\n        if (typeof group.pull === 'function') {\n          return group.pull(to, from, dragEl, evt);\n        }\n        return group.pull;\n      },\n      checkPut: (to: ISortable, from: ISortable, dragEl: HTMLElement, evt: Event): boolean => {\n        if (!group.put) return false;\n        if (Array.isArray(group.put)) {\n          const fromGroup = (from as Sortable).normalizedGroup;\n          return group.put.includes(fromGroup?.name ?? '');\n        }\n        if (typeof group.put === 'function') {\n          return group.put(to, from, dragEl, evt);\n        }\n        return !!group.put;\n      },\n      revertClone: group.revertClone ?? false,\n    };\n\n    // Register group cleanup\n    this.cleanupManager.registerCustomCleanup(this.instanceId, () => {\n      this.normalizedGroup = null;\n    });\n  }\n}\n"],"names":["animateElement"],"mappings":"AAGA;;AAEG;AACG,SAAU,YAAY,CAAC,GAAU,EAAA;IACrC,OAAO,SAAS,IAAI,GAAG;AACzB;AAEM,SAAU,cAAc,CAAC,GAAU,EAAA;IACvC,OAAO,aAAa,IAAI,GAAG;AAC7B;AAEA;;;;AAIG;AACG,SAAU,iBAAiB,CAAC,GAAuB,EAAA;AACvD,IAAA,IAAI,YAAY,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;AACvC,QAAA,OAAO,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;;SAChB,IAAI,cAAc,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,WAAW,KAAK,OAAO,EAAE;AAC7D,QAAA,OAAO,GAAG;;AAEZ,IAAA,OAAO,IAAI;AACb;AAEA;;;;AAIG;AACG,SAAU,mBAAmB,CAAC,GAAuB,EAAA;AACzD,IAAA,MAAM,KAAK,GAAG,iBAAiB,CAAC,GAAG,CAAC;IACpC,IAAI,KAAK,EAAE;QACT,OAAO;YACL,OAAO,EAAE,KAAK,CAAC,OAAO;YACtB,OAAO,EAAE,KAAK,CAAC,OAAO;SACvB;;;AAIH,IAAA,IAAI,SAAS,IAAI,GAAG,EAAE;QACpB,OAAO;YACL,OAAO,EAAE,GAAG,CAAC,OAAO;YACpB,OAAO,EAAE,GAAG,CAAC,OAAO;SACrB;;AAGH,IAAA,OAAO,IAAI;AACb;;AC5CA,MAAM,WAAW,GAAiB;AAChC,IAAA,OAAO,EAAE,KAAK;AACd,IAAA,OAAO,EAAE,KAAK;CACf;MAOY,cAAc,CAAA;AACjB,IAAA,KAAK,GAAmC,IAAI,GAAG,EAAE;IACjD,OAAO,QAAQ;AAEvB,IAAA,WAAA,GAAA;AAEO,IAAA,OAAO,WAAW,GAAA;AACvB,QAAA,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE;AAC5B,YAAA,cAAc,CAAC,QAAQ,GAAG,IAAI,cAAc,EAAE;;QAEhD,OAAO,cAAc,CAAC,QAAQ;;AAGxB,IAAA,mBAAmB,CAAC,EAA0B,EAAE,KAAa,EAAE,EAA6B,EAAA;QAClG,EAAE,CAAC,mBAAmB,CAAC,KAAK,EAAE,EAAmB,EAAE,WAAW,CAAC;;AAG1D,IAAA,qBAAqB,CAAC,UAAkB,EAAE,OAA+B,EAAE,KAAa,EAAE,OAAkC,EAAA;QACjI,OAAO,CAAC,gBAAgB,CAAC,KAAK,EAAE,OAAwB,EAAE,WAAW,CAAC;AACtE,QAAA,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;AACvB,YAAA,IAAI,EAAE,OAAO;AACb,YAAA,OAAO,EAAE,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAO,EAAE,KAAK,EAAE,OAAO,CAAC;AACjE,SAAA,CAAC;;IAGG,aAAa,CAAC,UAAkB,EAAE,OAAe,EAAA;AACtD,QAAA,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;AACvB,YAAA,IAAI,EAAE,OAAO;AACb,YAAA,OAAO,EAAE,MAAM,YAAY,CAAC,OAAO,CAAC;AACrC,SAAA,CAAC;;IAGG,wBAAwB,CAAC,UAAkB,EAAE,OAAmB,EAAA;AACrE,QAAA,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;AACvB,YAAA,IAAI,EAAE,WAAW;YACjB,OAAO;AACR,SAAA,CAAC;;IAGG,qBAAqB,CAAC,UAAkB,EAAE,OAAmB,EAAA;AAClE,QAAA,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;AACvB,YAAA,IAAI,EAAE,QAAQ;YACd,OAAO;AACR,SAAA,CAAC;;IAGI,OAAO,CAAC,UAAkB,EAAE,IAAkB,EAAA;QACpD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;YAC/B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,EAAE,IAAI,GAAG,EAAE,CAAC;;AAEvC,QAAA,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,CAAE,CAAC,GAAG,CAAC,IAAI,CAAC;;AAGhC,IAAA,OAAO,CAAC,UAAkB,EAAA;QAC/B,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,CAAC;AACxC,QAAA,IAAI,CAAC,KAAK;YAAE;;AAGZ,QAAA,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC;;AAGvC,QAAA,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC;;IAGxB,UAAU,GAAA;QACf,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,MAAyB,EAAE,UAAkB,KAAI;AACnE,YAAA,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC;AAC1B,SAAC,CAAC;AACF,QAAA,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE;;AAErB;;AClFD;AACO,MAAM,qBAAqB,GAAG,MAAM,CAAC,kBAAkB,CAAC;MAsClD,aAAa,CAAA;IAChB,OAAO,QAAQ;AACf,IAAA,KAAK;AACL,IAAA,SAAS,GAA6B,IAAI,GAAG,EAAE;AAC/C,IAAA,cAAc;AAEtB,IAAA,WAAA,GAAA;QACE,IAAI,CAAC,KAAK,GAAG;AACX,YAAA,cAAc,EAAE,IAAI;YACpB,SAAS,EAAE,IAAI,GAAG,EAAE;AACpB,YAAA,aAAa,EAAE;AACb,gBAAA,MAAM,EAAE,KAAK;AACb,gBAAA,QAAQ,EAAE,IAAI;AACd,gBAAA,MAAM,EAAE,IAAI;AACZ,gBAAA,OAAO,EAAE,IAAI;AACb,gBAAA,OAAO,EAAE,IAAI;AACb,gBAAA,QAAQ,EAAE,IAAI;AACd,gBAAA,MAAM,EAAE,IAAI;AACZ,gBAAA,UAAU,EAAE,IAAI;AAChB,gBAAA,QAAQ,EAAE,IAAI;AACd,gBAAA,QAAQ,EAAE,IAAI;AACd,gBAAA,iBAAiB,EAAE,IAAI;AACvB,gBAAA,iBAAiB,EAAE,IAAI;AACvB,gBAAA,KAAK,EAAE,KAAK;AACZ,gBAAA,QAAQ,EAAE;AACR,oBAAA,OAAO,EAAE,CAAC;AACV,oBAAA,OAAO,EAAE,CAAC;AACV,oBAAA,QAAQ,EAAE,CAAC;AACX,oBAAA,QAAQ,EAAE,CAAC;AACX,oBAAA,EAAE,EAAE,CAAC;AACL,oBAAA,EAAE,EAAE,CAAC;AACN,iBAAA;AACF,aAAA;SACF;AACD,QAAA,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC,WAAW,EAAE;;AAG7C,IAAA,OAAO,WAAW,GAAA;AACvB,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE;AAC3B,YAAA,aAAa,CAAC,QAAQ,GAAG,IAAI,aAAa,EAAE;;QAE9C,OAAO,aAAa,CAAC,QAAQ;;;IAIxB,gBAAgB,CAAC,EAAe,EAAE,QAAmB,EAAA;QAC1D,IAAI,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AAChC,YAAA,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC;;QAE5D,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,EAAE,QAAQ,CAAC;AACrC,QAAA,EAAsB,CAAC,qBAAqB,CAAC,GAAG,QAAQ;QACzD,IAAI,CAAC,eAAe,EAAE;;AAGjB,IAAA,eAAe,CAAC,UAAkB,EAAA;;AAEvC,QAAA,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,UAAU,CAAC;;QAGvC,IAAI,eAAe,GAAuB,IAAI;AAC9C,QAAA,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE,KAAI;AAC5C,YAAA,IAAK,QAAgB,CAAC,UAAU,KAAK,UAAU,EAAE;gBAC/C,eAAe,GAAG,EAAE;;AAExB,SAAC,CAAC;QAEF,IAAI,eAAe,EAAE;AACnB,YAAA,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC;;;AAIjC,IAAA,cAAc,CAAC,EAAe,EAAA;QACnC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC;AAC/B,QAAA,OAAQ,EAAsB,CAAC,qBAAqB,CAAC;QACrD,IAAI,CAAC,eAAe,EAAE;;AAGjB,IAAA,WAAW,CAAC,EAAe,EAAA;;AAEhC,QAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC;AAC7C,QAAA,IAAI,QAAQ;AAAE,YAAA,OAAO,QAAQ;;AAG7B,QAAA,OAAQ,EAAsB,CAAC,qBAAqB,CAAC;;;AAIhD,IAAA,SAAS,CAAC,QAA6B,EAAA;AAC5C,QAAA,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC;QAC5B,OAAO,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC;;IAGtC,eAAe,GAAA;AACrB,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE;AAC7B,QAAA,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,KAAK,QAAQ,CAAC,KAAK,CAAC,CAAC;;;IAIhD,QAAQ,GAAA;QACb,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;;;AAIlC,IAAA,SAAS,CAAC,QAAqB,EAAE,UAAkB,CAAC,EAAE,UAAkB,CAAC,EAAA;QAC9E,IAAI,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,EAAE;AACnC,YAAA,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC;;QAGvD,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC;QAC3C,IAAI,CAAC,QAAQ,EAAE;AACb,YAAA,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC;;AAG3D,QAAA,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,QAAQ;AACpC,QAAA,IAAI,CAAC,KAAK,CAAC,aAAa,GAAG;AACzB,YAAA,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa;AAC3B,YAAA,MAAM,EAAE,IAAI;YACZ,QAAQ;AACR,YAAA,QAAQ,EAAE,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC;AACxC,YAAA,QAAQ,EAAE;gBACR,OAAO;gBACP,OAAO;AACP,gBAAA,QAAQ,EAAE,OAAO;AACjB,gBAAA,QAAQ,EAAE,OAAO;AACjB,gBAAA,EAAE,EAAE,CAAC;AACL,gBAAA,EAAE,EAAE,CAAC;AACN,aAAA;SACF;QACD,IAAI,CAAC,eAAe,EAAE;;IAGjB,kBAAkB,CAAC,OAAe,EAAE,OAAe,EAAA;QACxD,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,QAAQ;AAChD,QAAA,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,QAAQ,GAAG;YAClC,OAAO;YACP,OAAO;YACP,QAAQ,EAAE,MAAM,CAAC,QAAQ;YACzB,QAAQ,EAAE,MAAM,CAAC,QAAQ;AACzB,YAAA,EAAE,EAAE,OAAO,GAAG,MAAM,CAAC,OAAO;AAC5B,YAAA,EAAE,EAAE,OAAO,GAAG,MAAM,CAAC,OAAO;SAC7B;QACD,IAAI,CAAC,eAAe,EAAE;;AAGjB,IAAA,kBAAkB,CAAC,QAAmH,EAAA;AAC3I,QAAA,IAAI,CAAC,KAAK,CAAC,aAAa,GAAG;AACzB,YAAA,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa;AAC3B,YAAA,GAAG,QAAQ;SACZ;QACD,IAAI,CAAC,eAAe,EAAE;;IAGjB,OAAO,GAAA;AACZ,QAAA,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,IAAI;AAChC,QAAA,IAAI,CAAC,KAAK,CAAC,aAAa,GAAG;AACzB,YAAA,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa;AAC3B,YAAA,MAAM,EAAE,KAAK;AACb,YAAA,QAAQ,EAAE,IAAI;AACd,YAAA,MAAM,EAAE,IAAI;AACZ,YAAA,OAAO,EAAE,IAAI;AACb,YAAA,OAAO,EAAE,IAAI;AACb,YAAA,QAAQ,EAAE,IAAI;AACd,YAAA,QAAQ,EAAE,IAAI;SACf;QACD,IAAI,CAAC,eAAe,EAAE;;IAGjB,oBAAoB,CAAC,SAAiB,EAAE,UAAkB,EAAA;;AAE/D,QAAA,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,QAAQ,GAAG;AAClC,YAAA,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,QAAQ;YACpC,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE,GAAG,UAAU;YACrD,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,QAAQ,CAAC,EAAE,GAAG,SAAS;SACrD;QACD,IAAI,CAAC,eAAe,EAAE;;;IAIjB,mBAAmB,CAAC,CAAS,EAAE,CAAS,EAAA;QAC7C,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM;QAC9C,IAAI,MAAM,EAAE;AACV,YAAA,MAAM,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO;AACxC,YAAA,MAAM,CAAC,KAAK,CAAC,OAAO,GAAG,MAAM;YAC7B,MAAM,OAAO,GAAG,QAAQ,CAAC,gBAAgB,CAAC,CAAC,EAAE,CAAC,CAAuB;AACrE,YAAA,MAAM,CAAC,KAAK,CAAC,OAAO,GAAG,WAAW;AAClC,YAAA,OAAO,OAAO;;QAEhB,OAAO,QAAQ,CAAC,gBAAgB,CAAC,CAAC,EAAE,CAAC,CAAuB;;;AAIvD,IAAA,cAAc,CAAC,GAAU,EAAA;AAC9B,QAAA,MAAM,EAAE,MAAM,EAAE,GAAG,GAAG;AACtB,QAAA,IAAI,EAAE,MAAM,YAAY,WAAW,CAAC;AAAE,YAAA,OAAO,IAAI;AAEjD,QAAA,IAAI,MAAM,CAAC,UAAU,EAAE;AACrB,YAAA,MAAM,KAAK,GAAG,iBAAiB,CAAC,GAAyB,CAAC;YAC1D,IAAI,KAAK,EAAE;AACT,gBAAA,MAAM,YAAY,GAAG,MAAM,CAAC,UAAU,CAAC,gBAAgB,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,OAAO,CAAC;AACrF,gBAAA,IAAI,YAAY,YAAY,WAAW,EAAE;AACvC,oBAAA,OAAO,YAAY;;;;AAKzB,QAAA,OAAO,MAAM;;;AAIP,IAAA,eAAe,CAAC,EAAe,EAAA;AACrC,QAAA,OAAO,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,aAAa,EAAE,QAAQ,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;;;IAI1D,iBAAiB,GAAA;AACtB,QAAA,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc;;IAG3B,gBAAgB,GAAA;AACrB,QAAA,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE,CAAC;;;AAIhD,IAAA,WAAW,CAAC,EAAe,EAAA;AAChC,QAAA,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,qBAAqB,IAAI,EAAE;;;IAI7D,gBAAgB,GAAA;AACrB,QAAA,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI;;;IAI3B,KAAK,GAAA;QACV,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;QAChE,IAAI,CAAC,OAAO,EAAE;AACd,QAAA,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE;;AAEzB;;AC3QM,MAAM,OAAO,GAAG,CAAC,EAAsB,EAAE,QAAgB,KAAa;AAC3E,IAAA,IAAI,CAAC,QAAQ,IAAI,CAAC,EAAE;AAAE,QAAA,OAAO,KAAK;AAElC,IAAA,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AACvB,QAAA,QAAQ,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC;;AAGlC,IAAA,IAAI;QACF,OAAO,EAAE,CAAC,OAAO,GAAG,QAAQ,CAAC,IAAI,KAAK;;AACtC,IAAA,MAAM;AACN,QAAA,OAAO,KAAK;;AAEhB,CAAC;AAEM,MAAM,eAAe,GAAG,CAAC,EAAQ,MAAa,EAAU,CAAC,IAAI,IAAI,EAAE,KAAK,QAAQ,IAAK,EAAU,CAAC,IAAI,CAAC,QAAQ,GAAI,EAAU,CAAC,IAAI,GAAI,EAAE,CAAC,UAAmB,CAAC;AAErJ,MAAA,OAAO,GAAG,CAAC,EAAsB,EAAE,QAAgB,EAAE,GAAA,GAAY,QAAQ,EAAE,UAAU,GAAG,KAAK,KAAwB;AAChI,IAAA,IAAI,CAAC,EAAE;AAAE,QAAA,OAAO,IAAI;IAEpB,IAAI,OAAO,GAAgB,EAAE;AAC7B,IAAA,GAAG;QACD,IAAI,CAAC,QAAQ,IAAI,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,OAAO,CAAC,UAAU,KAAK,GAAG,IAAI,OAAO,CAAC,OAAsB,EAAE,QAAQ,CAAC,GAAG,OAAO,CAAC,OAAsB,EAAE,QAAQ,CAAC,CAAC,MAAM,UAAU,IAAI,OAAO,KAAK,GAAG,CAAC,EAAE;AACxM,YAAA,OAAO,OAAsB;;QAG/B,IAAI,OAAO,KAAK,GAAG;YAAE;KACtB,SAAS,OAAO,GAAG,eAAe,CAAC,OAAO,CAAC;AAE5C,IAAA,OAAO,IAAI;AACb;AAEO,MAAM,WAAW,GAAG,CAAC,EAAe,EAAE,IAAY,EAAE,KAAc,KAAU;AACjF,IAAA,IAAI,CAAC,EAAE,IAAI,CAAC,IAAI;QAAE;AAClB,IAAA,EAAE,CAAC,SAAS,GAAG,KAAK,GAAG,KAAK,GAAG,QAAQ,CAAC,CAAC,IAAI,CAAC;AAChD,CAAC;AAIM,MAAM,GAAG,GAAG,CAAC,EAAe,EAAE,IAA4B,EAAE,GAAqB,KAAmB;IACzG,IAAI,CAAC,EAAE,EAAE,KAAK;QAAE;AAEhB,IAAA,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;AAC5B,QAAA,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,KAAI;AAC5C,YAAA,IAAI,EAAE,GAAG,IAAI,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;AACnD,gBAAA,GAAG,GAAG,CAAA,QAAA,EAAW,GAAG,CAAA,CAAE;;YAExB,EAAE,CAAC,KAAK,CAAC,GAAU,CAAC,GAAG,CAAA,EAAG,KAAK,CAAA,EAAG,OAAO,KAAK,KAAK,QAAQ,GAAG,EAAE,GAAG,IAAI,CAAA,CAAE;AAC3E,SAAC,CAAC;QACF;;AAGF,IAAA,IAAI,GAAG,KAAK,SAAS,EAAE;AACrB,QAAA,OAAO,gBAAgB,CAAC,EAAE,CAAC,CAAC,IAAW,CAAC;;AAG1C,IAAA,IAAI,EAAE,IAAI,IAAI,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;AACrD,QAAA,IAAI,GAAG,CAAA,QAAA,EAAW,IAAI,CAAA,CAAE;;IAG1B,EAAE,CAAC,KAAK,CAAC,IAAW,CAAC,GAAG,CAAA,EAAG,GAAG,CAAA,EAAG,OAAO,GAAG,KAAK,QAAQ,GAAG,EAAE,GAAG,IAAI,CAAA,CAAE;AACxE,CAAC;AAEM,MAAM,MAAM,GAAG,CAAC,EAAwB,EAAE,QAAQ,GAAG,KAAK,KAAoB;IACnF,IAAI,UAAU,GAAG,EAAE;AAEnB,IAAA,IAAI,OAAO,EAAE,KAAK,QAAQ,EAAE;QAC1B,UAAU,GAAG,EAAE;;SACV;QACL,IAAI,OAAO,GAAuB,EAAE;AACpC,QAAA,GAAG;YACD,MAAM,SAAS,GAAG,GAAG,CAAC,OAAO,EAAE,WAAW,CAAC;AAC3C,YAAA,IAAI,SAAS,IAAI,SAAS,KAAK,MAAM,EAAE;AACrC,gBAAA,UAAU,GAAG,CAAG,EAAA,SAAS,CAAI,CAAA,EAAA,UAAU,EAAE;;SAE5C,QAAQ,CAAC,QAAQ,KAAK,OAAO,GAAG,OAAO,CAAC,aAAa,CAAC;;AAGzD,IAAA,MAAM,iBAAiB,GAAG,MAAM,CAAC,SAAS,IAAI,MAAM,CAAC,eAAe,IAAI,MAAM,CAAC,SAAS,IAAI,MAAM,CAAC,WAAW;AAC9G,IAAA,OAAO,iBAAiB,GAAI,IAAI,iBAAiB,CAAC,UAAU,CAAa,GAAG,IAAI;AAClF,CAAC;MAEY,OAAO,GAAG,CAAC,EAAwB,EAAE,yBAAyB,GAAG,KAAK,EAAE,yBAAyB,GAAG,KAAK,EAAE,SAAS,GAAG,KAAK,EAAE,SAAuB,KAAa;AAC7K,IAAA,IAAI,EAAE,KAAK,MAAM,EAAE;QACjB,OAAO;AACL,YAAA,GAAG,EAAE,CAAC;AACN,YAAA,IAAI,EAAE,CAAC;YACP,MAAM,EAAE,MAAM,CAAC,WAAW;YAC1B,KAAK,EAAE,MAAM,CAAC,UAAU;YACxB,KAAK,EAAE,MAAM,CAAC,UAAU;YACxB,MAAM,EAAE,MAAM,CAAC,WAAW;AAC1B,YAAA,CAAC,EAAE,CAAC;AACJ,YAAA,CAAC,EAAE,CAAC;YACJ,MAAM,GAAA;gBACJ,OAAO;oBACL,CAAC,EAAE,IAAI,CAAC,CAAC;oBACT,CAAC,EAAE,IAAI,CAAC,CAAC;oBACT,GAAG,EAAE,IAAI,CAAC,GAAG;oBACb,KAAK,EAAE,IAAI,CAAC,KAAK;oBACjB,MAAM,EAAE,IAAI,CAAC,MAAM;oBACnB,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,KAAK,EAAE,IAAI,CAAC,KAAK;oBACjB,MAAM,EAAE,IAAI,CAAC,MAAM;iBACpB;aACF;SACS;;AAGd,IAAA,MAAM,MAAM,GAAI,EAAkB,CAAC,qBAAqB,EAAE;AAC1D,IAAA,IAAI,GAAG,GAAG,MAAM,CAAC,GAAG;AACpB,IAAA,IAAI,IAAI,GAAG,MAAM,CAAC,IAAI;AACtB,IAAA,IAAI,MAAM,GAAG,MAAM,CAAC,MAAM;AAC1B,IAAA,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK;AACxB,IAAA,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,MAAM;IAE9B,IAAI,CAAC,yBAAyB,IAAI,yBAAyB,KAAK,EAAE,KAAK,MAAM,EAAE;AAC7E,QAAA,SAAS,GAAG,SAAS,IAAM,EAAkB,CAAC,UAA0B;AAExE,QAAA,GAAG;AACD,YAAA,IAAI,SAAS,EAAE,qBAAqB,KAAK,GAAG,CAAC,SAAS,EAAE,WAAW,CAAC,KAAK,MAAM,KAAK,yBAAyB,IAAI,GAAG,CAAC,SAAS,EAAE,UAAU,CAAC,KAAK,QAAQ,CAAC,CAAC,EAAE;AAC1J,gBAAA,MAAM,aAAa,GAAG,SAAS,CAAC,qBAAqB,EAAE;AACvD,gBAAA,MAAM,SAAS,GAAG,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,kBAAkB,CAAW,CAAC,IAAI,CAAC;AAC7E,gBAAA,MAAM,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,mBAAmB,CAAW,CAAC,IAAI,CAAC;AAE/E,gBAAA,GAAG,IAAI,aAAa,CAAC,GAAG,GAAG,SAAS;AACpC,gBAAA,IAAI,IAAI,aAAa,CAAC,IAAI,GAAG,UAAU;AACvC,gBAAA,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC,MAAM;AAC5B,gBAAA,KAAK,GAAG,IAAI,GAAG,MAAM,CAAC,KAAK;gBAC3B;;SAEH,SAAS,SAAS,GAAG,SAAS,CAAC,UAAyB;;AAG3D,IAAA,IAAI,SAAS,IAAI,EAAE,KAAK,MAAM,EAAE;QAC9B,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAS,IAAK,EAAkB,CAAC;QACzD,IAAI,QAAQ,EAAE;YACZ,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,GAAG,QAAQ;YACzC,GAAG,IAAI,MAAM;YACb,IAAI,IAAI,MAAM;YACd,KAAK,IAAI,MAAM;YACf,MAAM,IAAI,MAAM;AAChB,YAAA,MAAM,GAAG,GAAG,GAAG,MAAM;AACrB,YAAA,KAAK,GAAG,IAAI,GAAG,KAAK;;;IAIxB,OAAO;QACL,GAAG;QACH,IAAI;QACJ,MAAM;QACN,KAAK;QACL,KAAK;QACL,MAAM;AACN,QAAA,CAAC,EAAE,IAAI;AACP,QAAA,CAAC,EAAE,GAAG;QACN,MAAM,GAAA;YACJ,OAAO;gBACL,CAAC,EAAE,IAAI,CAAC,CAAC;gBACT,CAAC,EAAE,IAAI,CAAC,CAAC;gBACT,GAAG,EAAE,IAAI,CAAC,GAAG;gBACb,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,MAAM,EAAE,IAAI,CAAC,MAAM;gBACnB,IAAI,EAAE,IAAI,CAAC,IAAI;gBACf,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,MAAM,EAAE,IAAI,CAAC,MAAM;aACpB;SACF;KACS;AACd;;ACtLA;;;;;AAKG;AACa,SAAA,aAAa,CAAmB,GAAQ,EAAE,GAAe,EAAA;AACvE,IAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACnC,QAAA,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,KAAI;AAC7C,YAAA,OAAO,GAAG,CAAC,GAAc,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,GAAc,CAAC;AACvD,SAAC,CAAC;AAEF,QAAA,IAAI,OAAO;AAAE,YAAA,OAAO,CAAC;;IAEvB,OAAO,EAAE;AACX;;ACZA;;AAEG;AACI,MAAM,WAAW,GAAG,CAAC,KAAc,EAAE,KAAc,KAAa;AACrE,IAAA,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC;AAC7N,CAAC;AAED;;AAEG;AACI,MAAM,iBAAiB,GAAG,CAAC,aAAsB,EAAE,QAAiB,EAAE,MAAe,EAAE,OAAyB,KAAY;AACjI,IAAA,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,GAAG,aAAa,CAAC,GAAG,EAAE,CAAC,CAAC;AACzD,IAAA,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC;AAC3D,IAAA,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;AAClD,IAAA,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;IAEpD,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,KAAK,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC;AACjF,CAAC;AAED;;AAEG;AACI,MAAM,YAAY,GAAG,CAAC,MAAmB,KAAa,MAAM,CAAC,WAAW;AAE/E;;AAEG;AACI,MAAM,OAAO,GAAG,CAAC,MAAmB,EAAE,WAAoB,EAAE,MAAe,EAAE,QAAgB,EAAE,OAAyB,KAAU;AACvI,IAAA,IAAI,CAAC,QAAQ;QAAE;;AAGf,IAAA,GAAG,CAAC,MAAM,EAAE,YAAY,EAAE,EAAE,CAAC;AAC7B,IAAA,GAAG,CAAC,MAAM,EAAE,WAAW,EAAE,EAAE,CAAC;;AAG5B,IAAA,MAAM,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC;AAC/B,IAAA,MAAM,MAAM,GAAG,QAAQ,EAAE,CAAC,IAAI,CAAC;AAC/B,IAAA,MAAM,MAAM,GAAG,QAAQ,EAAE,CAAC,IAAI,CAAC;;AAG/B,IAAA,MAAM,UAAU,GAAG,CAAC,WAAW,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI,MAAM;AAC5D,IAAA,MAAM,UAAU,GAAG,CAAC,WAAW,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,IAAI,MAAM;;AAG1D,IAAA,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC,UAAU;AAChC,IAAA,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC,UAAU;;IAGhC,GAAG,CAAC,MAAM,EAAE,WAAW,EAAE,CAAe,YAAA,EAAA,UAAU,CAAM,GAAA,EAAA,UAAU,CAAO,KAAA,CAAA,CAAC;;IAG1E,YAAY,CAAC,MAAM,CAAC;;IAGpB,GAAG,CAAC,MAAM,EAAE,YAAY,EAAE,aAAa,QAAQ,CAAA,EAAA,EAAK,OAAO,CAAC,MAAM,GAAG,GAAG,GAAG,OAAO,CAAC,MAAM,GAAG,EAAE,CAAE,CAAA,CAAC;AACjG,IAAA,GAAG,CAAC,MAAM,EAAE,WAAW,EAAE,oBAAoB,CAAC;;AAG9C,IAAA,IAAI,MAAM,CAAC,QAAQ,EAAE;AACnB,QAAA,YAAY,CAAC,MAAM,CAAC,QAAkB,CAAC;;;IAIzC,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC,MAAK;AACvC,QAAA,GAAG,CAAC,MAAM,EAAE,YAAY,EAAE,EAAE,CAAC;AAC7B,QAAA,GAAG,CAAC,MAAM,EAAE,WAAW,EAAE,EAAE,CAAC;AAC5B,QAAA,MAAM,CAAC,QAAQ,GAAG,KAAK;AACvB,QAAA,MAAM,CAAC,UAAU,GAAG,KAAK;AACzB,QAAA,MAAM,CAAC,UAAU,GAAG,KAAK;KAC1B,EAAE,QAAQ,CAAsB;AACnC;;ACjEA;;AAEG;MACU,qBAAqB,CAAA;IACxB,eAAe,GAAsB,EAAE;AACvC,IAAA,mBAAmB;AACnB,IAAA,QAAQ;AACR,IAAA,KAAK;AACL,IAAA,cAAc;AACd,IAAA,UAAU;AAElB,IAAA,WAAA,CAAY,QAAmB,EAAA;AAC7B,QAAA,IAAI,CAAC,QAAQ,GAAG,QAAQ;AACxB,QAAA,IAAI,CAAC,KAAK,GAAG,aAAa,CAAC,WAAW,EAAE;AACxC,QAAA,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC,WAAW,EAAE;AAClD,QAAA,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,uBAAuB,CAAC;;AAGnD;;AAEG;IACI,qBAAqB,GAAA;AAC1B,QAAA,IAAI,CAAC,eAAe,GAAG,EAAE;AACzB,QAAA,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS;YAAE;QAEtC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;AAC/C,QAAA,MAAM,QAAQ,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC;AAEtD,QAAA,QAAQ,CAAC,OAAO,CAAC,CAAC,KAAK,KAAI;AACzB,YAAA,IAAI,EAAE,KAAK,YAAY,WAAW,CAAC;gBAAE;AACrC,YAAA,IAAI,GAAG,CAAC,KAAK,EAAE,SAAS,CAAC,KAAK,MAAM,IAAI,KAAK,KAAK,SAAS,CAAC,OAAO;gBAAE;AAErE,YAAA,MAAM,KAAK,GAAoB;AAC7B,gBAAA,MAAM,EAAE,KAAK;AACb,gBAAA,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC;aACrB;AAED,YAAA,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC;;YAGhC,MAAM,QAAQ,GAAG,EAAE,GAAG,KAAK,CAAC,IAAI,EAAE;;AAGlC,YAAA,IAAI,KAAK,CAAC,qBAAqB,EAAE;AAC/B,gBAAA,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE,QAAQ,CAAC;;AAG9C,YAAA,KAAK,CAAC,QAAQ,GAAG,QAAQ;AAC3B,SAAC,CAAC;;AAGJ;;AAEG;AACI,IAAA,iBAAiB,CAAC,KAAsB,EAAA;AAC7C,QAAA,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC;;AAGlC;;AAEG;AACI,IAAA,oBAAoB,CAAC,MAAmB,EAAA;AAC7C,QAAA,MAAM,KAAK,GAAG,aAAa,CAAC,IAAI,CAAC,eAAe,EAAE,EAAE,MAAM,EAAE,CAAC;AAC7D,QAAA,IAAI,KAAK,KAAK,EAAE,EAAE;YAChB,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;;;AAIzC;;AAEG;AACI,IAAA,UAAU,CAAC,QAAqB,EAAA;QACrC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,EAAE;AACpC,YAAA,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC;YAC7B;;QAGF,MAAM,EAAE,SAAS,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,sBAAsB,EAAE;QAEhE,IAAI,CAAC,gBAAgB,CAAC,SAAS,EAAE,WAAW,EAAE,QAAQ,CAAC;AACvD,QAAA,IAAI,CAAC,eAAe,GAAG,EAAE;;AAG3B;;AAEG;AACI,IAAA,OAAO,CAAC,MAAmB,EAAE,WAAoB,EAAE,MAAe,EAAE,QAAgB,EAAA;AACzF,QAAAA,OAAc,CAAC,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC;;AAG9E;;;;;;AAMG;IACK,sBAAsB,CAAC,OAAoB,EAAE,IAAa,EAAA;QAChE,MAAM,cAAc,GAAW,gBAAgB,CAAC,OAAO,CAAC,CAAC,SAAS;AAClE,QAAA,IAAI,cAAc,IAAI,cAAc,KAAK,MAAM,EAAE;AAC/C,YAAA,MAAM,MAAM,GAAc,IAAI,SAAS,CAAC,cAAc,CAAC;;YAEvD,OAAO,IAAI,OAAO,CAChB,IAAI,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG;AACnB,YAAA,IAAI,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG;AACnB,YAAA,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,MAAM,CACZ;;AAEH,QAAA,OAAO,IAAI;;AAGb;;AAEG;IACK,sBAAsB,GAAA;QAC5B,IAAI,SAAS,GAAG,KAAK;QACrB,IAAI,WAAW,GAAG,CAAC;QAEnB,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,KAAK,KAAI;YACrC,MAAM,QAAQ,GAAG,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC;YACvD,IAAI,QAAQ,EAAE;gBACZ,SAAS,GAAG,IAAI;gBAChB,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,QAAQ,CAAC;gBAC7C,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,MAAM,EAAE,QAAQ,CAAC;;AAEpD,SAAC,CAAC;AAEF,QAAA,OAAO,EAAE,SAAS,EAAE,WAAW,EAAE;;AAGnC;;;;;;;AAOG;AACK,IAAA,0BAA0B,CAAC,KAAsB,EAAA;AACvD,QAAA,MAAM,EAAE,MAAM,EAAE,GAAG,KAAK;AACxB,QAAA,MAAM,WAAW,GAAY,OAAO,CAAC,MAAM,CAAC;QAC5C,IAAI,QAAQ,GAAW,CAAC;;QAGxB,IAAI,MAAM,CAAC,qBAAqB,IAAI,MAAM,CAAC,YAAY,IAAI,MAAM,CAAC,UAAU,IAAI,WAAW,CAAC,MAAM,CAAC,YAAY,EAAE,WAAW,CAAC,EAAE;YAC7H,QAAQ,GAAG,iBAAiB,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,YAAY,EAAE,MAAM,CAAC,UAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC;;;AAIzG,QAAA,IAAI,MAAM,CAAC,QAAQ,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,MAAM,CAAC,QAAQ,CAAC,EAAE;;AAEjE,YAAA,IAAI,CAAC,uBAAuB,CAAC,MAAM,EAAE,WAAW,CAAC;;YAGjD,IAAI,CAAC,QAAQ,EAAE;gBACb,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,IAAI,CAAC;;AAGjD,YAAA,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,KAAK,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,CAAC;;AAGzD,QAAA,OAAO,QAAQ;;AAGjB;;AAEG;;;;AAKH;;AAEG;IACK,uBAAuB,CAAC,MAAmB,EAAE,WAAoB,EAAA;AACvE,QAAA,MAAM,CAAC,YAAY,GAAG,MAAM,CAAC,QAAS;AACtC,QAAA,MAAM,CAAC,UAAU,GAAG,WAAW;;AAGjC;;AAEG;IACK,mBAAmB,CAAC,MAAmB,EAAE,QAAgB,EAAA;AAC/D,QAAA,IAAI,MAAM,CAAC,mBAAmB,EAAE;AAC9B,YAAA,YAAY,CAAC,MAAM,CAAC,mBAAmB,CAAC;;QAG1C,MAAM,CAAC,mBAAmB,GAAG,MAAM,CAAC,UAAU,CAAC,MAAK;AAClD,YAAA,MAAM,CAAC,aAAa,GAAG,CAAC;AACxB,YAAA,MAAM,CAAC,YAAY,GAAG,IAAI;AAC1B,YAAA,MAAM,CAAC,QAAQ,GAAG,IAAI;AACtB,YAAA,MAAM,CAAC,UAAU,GAAG,IAAI;AACxB,YAAA,MAAM,CAAC,qBAAqB,GAAG,IAAI;AACnC,YAAA,MAAM,CAAC,mBAAmB,GAAG,SAAS;SACvC,EAAE,QAAQ,CAAC;;AAGZ,QAAA,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,EAAE,MAAM,CAAC,mBAAmB,CAAC;AAC9E,QAAA,MAAM,CAAC,qBAAqB,GAAG,QAAQ;;AAGzC;;AAEG;AACK,IAAA,gBAAgB,CAAC,SAAkB,EAAE,QAAgB,EAAE,QAAqB,EAAA;AAClF,QAAA,IAAI,IAAI,CAAC,mBAAmB,EAAE;AAC5B,YAAA,YAAY,CAAC,IAAI,CAAC,mBAAmB,CAAC;;QAGxC,IAAI,CAAC,SAAS,EAAE;YACd,QAAQ,IAAI;YACZ;;QAGF,IAAI,CAAC,mBAAmB,GAAG,MAAM,CAAC,UAAU,CAAC,MAAK;YAChD,QAAQ,IAAI;AACZ,YAAA,IAAI,CAAC,mBAAmB,GAAG,SAAS;SACrC,EAAE,QAAQ,CAAC;;AAGZ,QAAA,IAAI,IAAI,CAAC,mBAAmB,EAAE;AAC5B,YAAA,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,mBAAmB,CAAC;;;AAIhF;;AAEG;AACK,IAAA,cAAc,CAAC,QAAqB,EAAA;AAC1C,QAAA,YAAY,CAAC,IAAI,CAAC,mBAAmB,CAAC;QACtC,QAAQ,IAAI;;IAGP,OAAO,GAAA;;QAEZ,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC;;AAE/C;;ACpPD;;;;AAIG;AACG,SAAU,iBAAiB,CAAC,OAAoB,EAAA;;AAEpD,IAAA,MAAM,UAAU,GAAa,CAAC,OAAO,CAAC,OAAO,IAAI,EAAE,EAAE,OAAO,CAAC,SAAS,IAAI,EAAE,EAAG,OAA4B,CAAC,GAAG,IAAI,EAAE,EAAG,OAA6B,CAAC,IAAI,IAAI,EAAE,EAAE,OAAO,CAAC,WAAW,IAAI,EAAE,CAAC;;IAG5L,MAAM,GAAG,GAAG,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC;IAChC,IAAI,IAAI,GAAG,CAAC;AAEZ,IAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACnC,MAAM,IAAI,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;QAC9B,IAAI,GAAG,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,GAAG,IAAI;AAChC,QAAA,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC;;IAGrB,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC;AACpC;AAEA;;;;;;AAMG;SACa,gBAAgB,CAAC,SAAsB,EAAE,iBAAyB,EAAE,UAAkB,EAAA;IACpG,MAAM,KAAK,GAAa,EAAE;AAC1B,IAAA,MAAM,QAAQ,GAAG,SAAS,CAAC,QAAQ;AAEnC,IAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACxC,QAAA,MAAM,EAAE,GAAG,QAAQ,CAAC,CAAC,CAAgB;QACrC,IAAI,OAAO,CAAC,EAAE,EAAE,iBAAiB,EAAE,SAAS,EAAE,KAAK,CAAC,EAAE;AACpD,YAAA,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,UAAU,CAAC,IAAI,iBAAiB,CAAC,EAAE,CAAC,CAAC;;;AAIpE,IAAA,OAAO,KAAK;AACd;;AC3CA;;AAEG;AASH;;;;;AAKG;AACI,MAAM,eAAe,GAAG,CAAC,EAAe,EAAE,aAAA,GAAyB,KAAK,KAAwB;AACrG,IAAA,IAAI,KAA0B;;IAG9B,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,CAAC,aAAa,EAAE;AAC5B,QAAA,OAAO,IAAI;;AAGb,IAAA,IAAI,MAAM,GAAuB,EAAE,CAAC,aAAa;IAEjD,OAAO,MAAM,EAAE;AACb,QAAA,KAAK,GAAG,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC;AACvC,QAAA,MAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,SAAS;;AAGnE,QAAA,IAAI,qBAAqB,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,aAAa,IAAI,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,EAAE;AAC1F,YAAA,OAAO,MAAM;;AAGf,QAAA,MAAM,GAAG,MAAM,CAAC,aAAa;;;AAI/B,IAAA,OAAQ,QAAQ,CAAC,gBAAgC,IAAI,QAAQ,CAAC,eAAe;AAC/E,CAAC;AAiBD;;AAEG;AACI,MAAM,SAAS,GAAG,CAAC,EAAwB,KAA+C;AAC/F,IAAA,IAAI,EAAE,KAAK,MAAM,EAAE;QACjB,OAAO;YACL,SAAS,EAAE,MAAM,CAAC,WAAW,IAAI,QAAQ,CAAC,eAAe,CAAC,SAAS;YACnE,UAAU,EAAE,MAAM,CAAC,WAAW,IAAI,QAAQ,CAAC,eAAe,CAAC,UAAU;SACtE;;IAGH,OAAO;QACL,SAAS,EAAG,EAAkB,CAAC,SAAS;QACxC,UAAU,EAAG,EAAkB,CAAC,UAAU;KAC3C;AACH,CAAC;;MC9DY,QAAQ,CAAA;IACX,OAAO,cAAc,GAAqB;AAChD,QAAA,KAAK,EAAE,IAAI;AACX,QAAA,IAAI,EAAE,IAAI;AACV,QAAA,QAAQ,EAAE,KAAK;AACf,QAAA,KAAK,EAAE,IAAI;AACX,QAAA,MAAM,EAAE,IAAI;AACZ,QAAA,SAAS,EAAE,IAAI;AACf,QAAA,aAAa,EAAE,CAAC;AAChB,QAAA,UAAU,EAAE,KAAK;AACjB,QAAA,qBAAqB,EAAE,IAAI;AAC3B,QAAA,iBAAiB,EAAE,IAAI;AACvB,QAAA,SAAS,EAAE,UAAU;AACrB,QAAA,aAAa,EAAE,mBAAmB;AAClC,QAAA,WAAW,EAAE,iBAAiB;AAC9B,QAAA,SAAS,EAAE,eAAe;AAC1B,QAAA,MAAM,EAAE,QAAQ;AAChB,QAAA,MAAM,EAAE,IAAI;AACZ,QAAA,eAAe,EAAE,IAAI;AACrB,QAAA,SAAS,EAAE,CAAC;AACZ,QAAA,MAAM,EAAE,IAAI;AACZ,QAAA,OAAO,EAAE,UAAU,YAA0B,EAAE,QAAqB,EAAA;YAClE,YAAY,CAAC,OAAO,CAAC,MAAM,EAAE,QAAQ,CAAC,WAAW,IAAI,EAAE,CAAC;SACzD;AACD,QAAA,UAAU,EAAE,KAAK;AACjB,QAAA,cAAc,EAAE,KAAK;AACrB,QAAA,UAAU,EAAE,SAAS;AACrB,QAAA,KAAK,EAAE,CAAC;AACR,QAAA,mBAAmB,EAAE,CAAC;AACtB,QAAA,aAAa,EAAE,KAAK;AACpB,QAAA,aAAa,EAAE,mBAAmB;AAClC,QAAA,cAAc,EAAE,KAAK;AACrB,QAAA,iBAAiB,EAAE,CAAC;QACpB,cAAc,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;AAC9B,QAAA,cAAc,EAAE,IAAI;AACpB,QAAA,oBAAoB,EAAE,CAAC;KACxB;AAEgB,IAAA,KAAK;AACL,IAAA,UAAU;AACV,IAAA,cAAc;AACvB,IAAA,gBAAgB;AAChB,IAAA,cAAc;IACd,eAAe,GAA0B,IAAI;AAE9C,IAAA,OAAO;AACP,IAAA,EAAE;IAET,WAAY,CAAA,EAAe,EAAE,OAAmC,EAAA;AAC9D,QAAA,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,CAAC,QAAQ,IAAI,EAAE,CAAC,QAAQ,KAAK,CAAC,EAAE;AAC5C,YAAA,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC;;AAG9E,QAAA,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,kBAAkB,CAAC;AAC5C,QAAA,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC,WAAW,EAAE;AAClD,QAAA,IAAI,CAAC,EAAE,GAAG,EAAE;AACZ,QAAA,IAAI,CAAC,OAAO,GAAG,EAAE,GAAG,QAAQ,CAAC,cAAc,EAAE,GAAG,OAAO,EAAE;AACzD,QAAA,IAAI,CAAC,KAAK,GAAG,aAAa,CAAC,WAAW,EAAE;;QAGxC,IAAI,CAAC,gBAAgB,GAAG,IAAI,qBAAqB,CAAC,IAAI,CAAC;QACvD,IAAI,CAAC,cAAc,CAAC,wBAAwB,CAAC,IAAI,CAAC,UAAU,EAAE,MAAK;AACjE,YAAA,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE;AACjC,SAAC,CAAC;;QAGF,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,EAAE,EAAE,IAAI,CAAC;;QAGrC,IAAI,CAAC,wBAAwB,EAAE;;AAG/B,QAAA,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE;YACtB,IAAI,CAAC,YAAY,EAAE;;;IAIf,wBAAwB,GAAA;AAC9B,QAAA,MAAM,iBAAiB,GAA8B,CAAC,GAAuB,KAAU;AACrF,YAAA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;AACtB,SAAC;;AAGD,QAAA,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE;AAC/B,YAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,EAAE,EAAE,aAAa,EAAE,iBAAiB,CAAC;;aAChG;AACL,YAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,EAAE,EAAE,WAAW,EAAE,iBAAiB,CAAC;AACnG,YAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,EAAE,EAAE,YAAY,EAAE,iBAAiB,CAAC;;;QAItG,MAAM,QAAQ,GAAG,eAAe,CAAC,IAAI,CAAC,EAAE,CAAC;AACzC,QAAA,IAAI,QAAQ,IAAI,QAAQ,KAAK,QAAQ,CAAC,eAAe,IAAI,QAAQ,KAAK,QAAQ,CAAC,gBAAgB,EAAE;AAC/F,YAAA,MAAM,aAAa,GAA8B,CAAC,GAAuB,KAAU;AACjF,gBAAA,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC;AACpB,aAAC;AAED,YAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,aAAa,CAAC;;;;IAKzF,MAAM,GAAG,CAAC,QAAiB,EAAE,UAAmB,EAAE,SAA4B,EAAE,OAA2B,KAAa;AAC9H,QAAA,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO;AAC5B,QAAA,MAAM,SAAS,GAAG,OAAO,CAAC,aAAa,IAAI,CAAC;AAC5C,QAAA,MAAM,UAAU,GAAG,OAAO,CAAC,UAAU,IAAI,KAAK;AAC9C,QAAA,MAAM,iBAAiB,GAAG,OAAO,CAAC,qBAAqB,IAAI,SAAS;AAEpE,QAAA,MAAM,KAAK,GAAG,UAAU,GAAG,KAAkB,GAAG,SAAS,GAAG,GAAG;QAC/D,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;AAE/C,QAAA,IAAI,SAAS,KAAK,UAAU,EAAE;YAC5B,MAAM,UAAU,GAAG,QAAQ,CAAC,GAAG,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC;YACrD,MAAM,YAAY,GAAG,UAAU,CAAC,GAAG,GAAG,UAAU,CAAC,MAAM,GAAG,CAAC;AAC3D,YAAA,MAAM,eAAe,GAAG,KAAK,GAAG,CAAC,UAAU,GAAG,YAAY,IAAI,UAAU,CAAC,MAAM,GAAG,SAAS,GAAG,CAAC,YAAY,GAAG,UAAU,IAAI,UAAU,CAAC,MAAM,GAAG,iBAAiB;YAEjK,IAAI,eAAe,EAAE;AACnB,gBAAA,OAAO,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,SAAS,CAAC,QAAQ,EAAE,KAAK,CAAC;;;aAE9D;YACL,MAAM,UAAU,GAAG,QAAQ,CAAC,IAAI,GAAG,QAAQ,CAAC,KAAK,GAAG,CAAC;YACrD,MAAM,YAAY,GAAG,UAAU,CAAC,IAAI,GAAG,UAAU,CAAC,KAAK,GAAG,CAAC;AAC3D,YAAA,MAAM,eAAe,GAAG,KAAK,GAAG,CAAC,UAAU,GAAG,YAAY,IAAI,UAAU,CAAC,KAAK,GAAG,SAAS,GAAG,CAAC,YAAY,GAAG,UAAU,IAAI,UAAU,CAAC,KAAK,GAAG,iBAAiB;YAE/J,IAAI,eAAe,EAAE;AACnB,gBAAA,OAAO,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,SAAS,CAAC,QAAQ,EAAE,KAAK,CAAC;;;AAIrE,QAAA,OAAO,KAAK;AACd,KAAC;AAEO,IAAA,iBAAiB,CAAC,MAA0B,EAAE,OAA2B,EAAE,eAAwB,EAAA;AACzG,QAAA,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO;AAAE,YAAA,OAAO,KAAK;AAErC,QAAA,MAAM,SAAS,GAAG,IAAI,WAAW,CAAC,eAAe,EAAE;AACjD,YAAA,OAAO,EAAE,IAAI;AACb,YAAA,UAAU,EAAE,IAAI;AAChB,YAAA,MAAM,EAAE;gBACN,MAAM;gBACN,OAAO;gBACP,eAAe;AAChB,aAAA;AACF,SAAA,CAAC;AAEF,QAAA,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,SAAS,CAAC;AAChC,QAAA,OAAO,CAAC,SAAS,CAAC,gBAAgB;;;AAI5B,IAAA,UAAU,GAAG,CAAC,GAAuB,KAAU;QACrD,IAAI,CAAC,GAAG,CAAC,UAAU;YAAE;QAErB,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,GAAG,CAAC;AAC7C,QAAA,IAAI,CAAC,MAAM;YAAE;AAEb,QAAA,MAAM,WAAW,GAAG,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,oBAAoB,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC;AAChF,QAAA,IAAI,CAAC,WAAW;YAAE;;AAGlB,QAAA,MAAM,WAAW,GAAG,mBAAmB,CAAC,GAAG,CAAC;AAC5C,QAAA,IAAI,CAAC,WAAW;YAAE;AAElB,QAAA,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,WAAW;;QAGxC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,WAAW,EAAE,OAAO,EAAE,OAAO,CAAC;;AAGnD,QAAA,MAAM,KAAK,GAAG,iBAAiB,CAAC,GAAG,CAAC;QACpC,IAAI,KAAK,EAAE;AACT,YAAA,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,OAAO,CAAC;;AAG7D,QAAA,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,WAAW,CAAC;AAClD,KAAC;IAEO,QAAQ,GAAG,MAAK;QACtB,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;QAC/C,IAAI,CAAC,SAAS,CAAC,QAAQ;YAAE;;QAGzB,IAAI,CAAC,gBAAgB,EAAE;;AAGvB,QAAA,MAAM,aAAa,GAAG,IAAI,CAAC,EAAE,CAAC,aAAa;AAC3C,QAAA,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE;AAC/B,YAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,aAAa,EAAE,aAAa,EAAE,IAAI,CAAC,aAA8B,CAAC;;aACxH;AACL,YAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,aAAa,EAAE,WAAW,EAAE,IAAI,CAAC,aAA8B,CAAC;AAC3H,YAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,aAAa,EAAE,WAAW,EAAE,IAAI,CAAC,aAA8B,CAAC;;AAE7H,QAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,aAAa,EAAE,UAAU,EAAE,IAAI,CAAC,UAA2B,CAAC;;AAGvH,QAAA,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC;YAC5B,MAAM,EAAE,SAAS,CAAC,QAAQ;AAC1B,YAAA,QAAQ,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC;AACnE,SAAA,CAAC;AACF,QAAA,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC;AACrC,KAAC;IAEO,uBAAuB,CAAC,KAAkC,EAAE,MAAmB,EAAA;AACrF,QAAA,MAAM,CAAC,KAAK,CAAC,UAAU,GAAG,WAAW;AACrC,QAAA,IAAI,CAAC,iBAAiB,CAAC,CAAC,CAAC,KAAK,CAAC;;AAG/B,QAAA,MAAM,KAAK,GAAI,IAAI,CAAC,OAA4B,CAAC,KAAK;AAEtD,QAAA,IAAI,IAAI,CAAC,gBAAgB,EAAE,EAAE;YAC3B,IAAI,CAAC,cAAc,GAAG,MAAM,CAAC,UAAU,CAAC,MAAK;gBAC3C,IAAI,CAAC,QAAQ,EAAE;AACf,gBAAA,IAAI,CAAC,cAAc,GAAG,SAAS;aAChC,EAAE,KAAK,CAAC;;AAGT,YAAA,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,cAAc,CAAC;;aAClE;YACL,IAAI,CAAC,QAAQ,EAAE;;;;AAKX,IAAA,aAAa,GAAG,CAAC,GAAuB,KAAU;QACxD,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;QAC/C,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,GAAG,CAAC,UAAU;YAAE;AAE1C,QAAA,MAAM,WAAW,GAAG,mBAAmB,CAAC,GAAG,CAAC;AAC5C,QAAA,IAAI,CAAC,WAAW;YAAE;AAElB,QAAA,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,WAAW;;QAGxC,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,OAAO,EAAE,OAAO,CAAC;AAE/C,QAAA,IAAI,SAAS,CAAC,MAAM,EAAE;YACpB,GAAG,CAAC,cAAc,EAAE;AACpB,YAAA,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC;;AAGzB,YAAA,MAAM,GAAG,GAAG,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;YACtD,MAAM,EAAE,GAAG,OAAO,GAAG,SAAS,CAAC,QAAQ,CAAC,OAAO;YAC/C,MAAM,EAAE,GAAG,OAAO,GAAG,SAAS,CAAC,QAAQ,CAAC,OAAO;AAE/C,YAAA,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,GAAG,CAAA,YAAA,EAAe,EAAE,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAA,GAAA,EAAM,EAAE,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAA,KAAA,CAAO;;AAC5F,aAAA,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE;YAC3B,MAAM,SAAS,GAAI,IAAI,CAAC,OAA4B,CAAC,mBAAmB,IAAI,CAAC;AAC7E,YAAA,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,GAAG,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,OAAO,GAAG,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;AAE7H,YAAA,IAAI,YAAY,IAAI,SAAS,EAAE;gBAC7B,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC;gBAC9C,IAAI,CAAC,QAAQ,EAAE;;;AAGrB,KAAC;AAEO,IAAA,UAAU,GAAG,CAAC,GAAuB,KAAU;QACrD,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;QAC/C,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ;YAAE;QAE9C,GAAG,CAAC,cAAc,EAAE;QACpB,GAAG,CAAC,eAAe,EAAE;AAErB,QAAA,IAAI,OAAe;AACnB,QAAA,IAAI,OAAe;;AAGnB,QAAA,IAAI,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE;YAC1B,MAAM,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;AAC5B,YAAA,IAAI,CAAC,KAAK;gBAAE;AACZ,YAAA,OAAO,GAAG,KAAK,CAAC,OAAO;AACvB,YAAA,OAAO,GAAG,KAAK,CAAC,OAAO;;AAClB,aAAA,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,EAAE;AAChC,YAAA,OAAO,GAAG,GAAG,CAAC,OAAO;AACrB,YAAA,OAAO,GAAG,GAAG,CAAC,OAAO;;aAChB;;AAEL,YAAA,OAAO,GAAG,GAAG,CAAC,OAAO;AACrB,YAAA,OAAO,GAAG,GAAG,CAAC,OAAO;;QAGvB,MAAM,QAAQ,GAAG,QAAQ,CAAC,gBAAgB,CAAC,OAAO,EAAE,OAAO,CAAuB;AAClF,QAAA,IAAI,CAAC,QAAQ;YAAE;AAEf,QAAA,MAAM,WAAW,GAAG,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,oBAAoB,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC;AAClF,QAAA,IAAI,CAAC,WAAW,IAAI,WAAW,KAAK,SAAS,CAAC,QAAQ;YAAE;AAExD,QAAA,MAAM,IAAI,GAAG,OAAO,CAAC,WAAW,CAAC;QACjC,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,WAAW,CAAC;;AAGrD,QAAA,MAAM,WAAW,GAAG,WAAW,CAAC,sBAA4C;AAC5E,QAAA,MAAM,WAAW,GAAG,WAAW,CAAC,kBAAwC;;QAGxE,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC;QAC1C,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,GAAG,CAAC;AAC1C,QAAA,MAAM,UAAU,GAAG,SAAS,KAAK,UAAU;QAC3C,MAAM,UAAU,GAAG,UAAU,GAAG,OAAO,GAAG,OAAO;QACjD,MAAM,MAAM,GAAG,UAAU,GAAG,OAAO,GAAG,OAAO;;AAG7C,QAAA,MAAM,YAAY,GAAG,UAAU,GAAG,MAAM;QACxC,MAAM,OAAO,GAAG,YAAY,GAAG,WAAW,GAAG,WAAW;;QAGxD,MAAM,QAAQ,GAAG,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC;;AAG5C,QAAA,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,CAAC,EAAE;;YAEnD,IAAI,CAAC,qBAAqB,EAAE;;YAG5B,IAAI,YAAY,EAAE;gBAChB,WAAW,CAAC,UAAU,EAAE,YAAY,CAAC,SAAS,CAAC,QAAQ,EAAE,WAAW,CAAC;;iBAChE;AACL,gBAAA,WAAW,CAAC,UAAU,EAAE,YAAY,CAAC,SAAS,CAAC,QAAQ,EAAE,WAAW,CAAC,WAAW,CAAC;;;YAInF,IAAI,CAAC,iBAAiB,CAAC;AACrB,gBAAA,MAAM,EAAE,WAAW;AACnB,gBAAA,IAAI,EAAE,OAAO,CAAC,WAAW,CAAC;AAC3B,aAAA,CAAC;;YAGF,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,OAAO,EAAE,OAAO,CAAC;;YAG/C,MAAM,QAAQ,GAAG,SAAS,CAAC,QAAQ,IAAI,EAAE;AACzC,YAAA,MAAM,QAAQ,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC;AAEzE,YAAA,IAAI,QAAQ,KAAK,QAAQ,EAAE;AACzB,gBAAA,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE;oBAC7B,QAAQ;oBACR,QAAQ;oBACR,MAAM,EAAE,SAAS,CAAC,QAAQ;AAC1B,oBAAA,MAAM,EAAE,WAAW;AACpB,iBAAA,CAAC;;;AAIJ,YAAA,IAAK,IAAI,CAAC,OAA4B,CAAC,SAAS,EAAE;gBAChD,IAAI,CAAC,UAAU,EAAE;;;AAGvB,KAAC;AAEO,IAAA,QAAQ,GAAG,CAAC,GAAuB,KAAU;QACnD,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;QAC/C,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM;YAAE;;QAG5C,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,GAAG,CAAC,MAAqB;;AAG3D,QAAA,MAAM,GAAG,GAAG,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;AACtD,QAAA,MAAM,EAAE,GAAG,SAAS,CAAC,QAAQ,CAAC,OAAO,GAAG,SAAS,CAAC,QAAQ,CAAC,QAAQ;AACnE,QAAA,MAAM,EAAE,GAAG,SAAS,CAAC,QAAQ,CAAC,OAAO,GAAG,SAAS,CAAC,QAAQ,CAAC,QAAQ;AAEnE,QAAA,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,GAAG,CAAA,YAAA,EAAe,EAAE,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAA,GAAA,EAAM,EAAE,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAA,KAAA,CAAO;;QAGjG,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,SAAS,EAAE,UAAU,CAAC;AACxD,KAAC;AAEO,IAAA,eAAe,GAAG,CAAC,GAAuB,KAAU;;QAE1D,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;QAC/C,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM;YAAE;;AAG5C,QAAA,MAAM,WAAW,GAAG,mBAAmB,CAAC,GAAG,CAAC;AAC5C,QAAA,IAAI,CAAC,WAAW;YAAE;AAElB,QAAA,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,WAAW;;AAGxC,QAAA,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC;;QAGtC,MAAM,aAAa,GAAG,QAAQ,CAAC,gBAAgB,CAAC,OAAO,EAAE,OAAO,CAAC;QACjE,IAAI,CAAC,aAAa,IAAI,EAAE,aAAa,YAAY,WAAW,CAAC,EAAE;AAC7D,YAAA,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC;YACrC;;;AAIF,QAAA,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC;;AAGrC,QAAA,IAAI,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,EAAE;YACvC,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC;AAC5D,YAAA,IAAI,cAAc,IAAI,cAAc,KAAK,IAAI,EAAE;AAC7C,gBAAA,cAAc,CAAC,cAAc,CAAC,GAAG,CAAC;gBAClC;;;;AAKJ,QAAA,MAAM,WAAW,GAAG,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC,oBAAoB,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC;AACvF,QAAA,IAAI,CAAC,WAAW,IAAI,WAAW,KAAK,SAAS,CAAC,QAAQ;YAAE;;QAGxD,MAAM,QAAQ,GAAG,OAAO,CAAC,SAAS,CAAC,MAAM,CAAC;AAC1C,QAAA,MAAM,UAAU,GAAG,OAAO,CAAC,WAAW,CAAC;QACvC,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,WAAW,CAAC;;QAGrD,MAAM,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,WAAW,EAAE,SAAS,CAAC;;AAG7D,QAAA,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,OAAO,CAAC,EAAE;YACzD,IAAI,CAAC,qBAAqB,EAAE;AAC5B,YAAA,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC;YAC1B,IAAI,CAAC,iBAAiB,CAAC;AACrB,gBAAA,MAAM,EAAE,WAAW;AACnB,gBAAA,IAAI,EAAE,OAAO,CAAC,WAAW,CAAC;AAC3B,aAAA,CAAC;;AAEN,KAAC;AAEO,IAAA,MAAM,GAAG,CAAC,GAAU,KAAU;QACpC,IAAI,GAAG,EAAE;YACP,GAAG,CAAC,cAAc,EAAE;;QAGtB,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;QAC/C,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM;YAAE;;AAG5C,QAAA,IAAI,SAAS,CAAC,MAAM,CAAC,UAAU,EAAE;YAC/B,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,SAAS,CAAC,MAAM,CAAC;;;QAI3D,MAAM,aAAa,GAAI,IAAI,CAAC,OAA4B,CAAC,aAAa,IAAI,mBAAmB;QAC7F,MAAM,aAAa,GAAI,IAAI,CAAC,OAA4B,CAAC,aAAa,IAAI,mBAAmB;AAE7F,QAAA,IAAI,SAAS,CAAC,QAAQ,EAAE;YACtB,WAAW,CAAC,SAAS,CAAC,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC;YACrD,WAAW,CAAC,SAAS,CAAC,QAAQ,EAAE,aAAa,EAAE,KAAK,CAAC;;;AAIvD,QAAA,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC;;AAG9B,QAAA,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;AACtB,KAAC;;IAGO,gBAAgB,CAAC,MAAmB,EAAE,SAA4B,EAAA;AACxE,QAAA,OAAO,SAAS,KAAK,UAAU,GAAI,MAAM,CAAC,kBAAyC,GAAI,MAAM,CAAC,sBAA6C;;AAGrI,IAAA,iBAAiB,GAAG,CAAC,EAAe,KAAsB;QAChE,IAAI,OAAO,GAAuB,EAAE;QAEpC,OAAO,OAAO,IAAI,OAAO,KAAK,QAAQ,CAAC,IAAI,EAAE;YAC3C,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC;AAChD,YAAA,IAAI,QAAQ;AAAE,gBAAA,OAAO,QAAQ;AAC7B,YAAA,OAAO,GAAG,OAAO,CAAC,aAAa;;AAGjC,QAAA,OAAO,IAAI;AACb,KAAC;AAEO,IAAA,0BAA0B,CAAC,IAAa,EAAA;QAC9C,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;AAC/C,QAAA,IAAI,SAAS,CAAC,MAAM,EAAE;AACpB,YAAA,GAAG,CAAC,SAAS,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,GAAG,EAAE,GAAG,MAAM,CAAC;;;IAIhD,gBAAgB,GAAA;QACtB,MAAM,SAAS,GAAwB,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;QACpE,IAAI,CAAC,SAAS,CAAC,QAAQ;YAAE;;AAGzB,QAAA,MAAM,SAAS,GAAiB,IAAI,CAAC,OAA4B,CAAC,cAAc,GAAG,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,EAAE;QAC1G,MAAM,YAAY,GAAuB,eAAe,CAAC,IAAI,CAAC,EAAE,CAAC;AACjE,QAAA,MAAM,qBAAqB,GAAY,CAAC,YAAY,IAAI,YAAY,KAAK,QAAQ,CAAC,IAAI,KAAK,KAAK;;QAGhG,MAAM,IAAI,GAAY,OAAO,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,EAAG,IAAI,CAAC,OAA4B,CAAC,cAAc,EAAE,IAAI,EAAE,SAAS,CAAC;;AAG3H,QAAA,MAAM,MAAM,GAAgB,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,CAAC;;QAG5E,IAAI,CAAC,mBAAmB,CAAC,MAAM,EAAE,IAAI,EAAE,qBAAqB,EAAE,YAAY,CAAC;;AAG3E,QAAA,SAAS,CAAC,WAAW,CAAC,MAAM,CAAC;QAC7B,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,EAAE,MAAM,EAAE,CAAC;;IAGnC,iBAAiB,CAAC,QAAqB,EAAE,IAAa,EAAA;QAC5D,MAAM,MAAM,GAAgB,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAgB;AACnE,QAAA,MAAM,EAAE,aAAa,GAAG,mBAAmB,EAAE,aAAa,GAAG,mBAAmB,EAAE,GAAG,IAAI,CAAC,OAAO;;AAGjG,QAAA,WAAW,CAAC,MAAM,EAAE,aAAa,EAAE,IAAI,CAAC;AACxC,QAAA,WAAW,CAAC,MAAM,EAAE,aAAa,EAAE,IAAI,CAAC;;AAGxC,QAAA,MAAM,UAAU,GAA2B;AACzC,YAAA,QAAQ,EAAE,OAAO;AACjB,YAAA,MAAM,EAAE,QAAQ;AAChB,YAAA,aAAa,EAAE,MAAM;AACrB,YAAA,KAAK,EAAE,CAAA,EAAG,IAAI,CAAC,KAAK,CAAI,EAAA,CAAA;AACxB,YAAA,MAAM,EAAE,CAAA,EAAG,IAAI,CAAC,MAAM,CAAI,EAAA,CAAA;AAC1B,YAAA,SAAS,EAAE,YAAY;AACvB,YAAA,MAAM,EAAE,GAAG;AACX,YAAA,OAAO,EAAE,KAAK;AACd,YAAA,UAAU,EAAE,EAAE;AACd,YAAA,SAAS,EAAE,EAAE;SACd;AAED,QAAA,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC;AACvB,QAAA,OAAO,MAAM;;AAGP,IAAA,mBAAmB,CAAC,MAAmB,EAAE,IAAa,EAAE,qBAA8B,EAAE,YAAgC,EAAA;QAC9H,IAAI,CAAC,qBAAqB,EAAE;YAC1B,GAAG,CAAC,MAAM,EAAE;AACV,gBAAA,GAAG,EAAE,CAAA,EAAG,IAAI,CAAC,GAAG,CAAI,EAAA,CAAA;AACpB,gBAAA,IAAI,EAAE,CAAA,EAAG,IAAI,CAAC,IAAI,CAAI,EAAA,CAAA;AACvB,aAAA,CAAC;YACF;;;AAIF,QAAA,MAAM,gBAAgB,GAAY,OAAO,CAAC,YAAa,CAAC;AACxD,QAAA,MAAM,MAAM,GAA8C,SAAS,CAAC,YAAa,CAAC;QAElF,GAAG,CAAC,MAAM,EAAE;AACV,YAAA,QAAQ,EAAE,UAAU;AACpB,YAAA,GAAG,EAAE,CAAA,EAAG,IAAI,CAAC,GAAG,GAAG,gBAAgB,CAAC,GAAG,GAAG,MAAM,CAAC,SAAS,CAAI,EAAA,CAAA;AAC9D,YAAA,IAAI,EAAE,CAAA,EAAG,IAAI,CAAC,IAAI,GAAG,gBAAgB,CAAC,IAAI,GAAG,MAAM,CAAC,UAAU,CAAI,EAAA,CAAA;AACnE,SAAA,CAAC;;;AAII,IAAA,YAAY,CAAC,GAAU,EAAA;QAC7B,OAAO,SAAS,IAAI,GAAG;;AAGjB,IAAA,WAAW,CAAC,GAAU,EAAA;QAC5B,OAAO,cAAc,IAAI,GAAG;;IAGtB,gBAAgB,GAAA;AACtB,QAAA,OAAO,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC;;AAGjD,IAAA,iBAAiB,CAAC,OAAgB,EAAA;AACxC,QAAA,MAAM,GAAG,GAAG,IAAI,CAAC,EAAE,CAAC,aAAa;AAEjC,QAAA,IAAK,IAAI,CAAC,OAA4B,CAAC,cAAc,EAAE;AACrD,YAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,EAAE,aAAa,EAAE,IAAI,CAAC,aAA8B,CAAC;AACnH,YAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,EAAE,WAAW,EAAE,IAAI,CAAC,MAAuB,CAAC;AAC1G,YAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,EAAE,eAAe,EAAE,IAAI,CAAC,MAAuB,CAAC;;aACzG;YACL,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,EAAE,OAAO,GAAG,WAAW,GAAG,WAAW,EAAE,IAAI,CAAC,aAA8B,CAAC;YACzI,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,EAAE,OAAO,GAAG,UAAU,GAAG,SAAS,EAAE,IAAI,CAAC,MAAuB,CAAC;YAC/H,IAAI,OAAO,EAAE;AACX,gBAAA,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,EAAE,aAAa,EAAE,IAAI,CAAC,MAAuB,CAAC;;;;AAK1G,IAAA,QAAQ,CAAC,MAAmB,EAAA;QAClC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;QAC/C,IAAI,CAAC,SAAS,CAAC,QAAQ;YAAE;AAEzB,QAAA,MAAM,QAAQ,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC;AACzE,QAAA,MAAM,QAAQ,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC;AAE7D,QAAA,IAAI,QAAQ,KAAK,QAAQ,EAAE;YACzB,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,SAAS,CAAC,QAAQ,EAAE,MAAM,CAAC;AAChD,YAAA,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE;gBAC7B,QAAQ;gBACR,QAAQ;gBACR,MAAM,EAAE,SAAS,CAAC,QAAQ;gBAC1B,MAAM;AACP,aAAA,CAAC;;;AAIE,IAAA,iBAAiB,CAAC,IAAY,EAAE,MAAA,GAA8B,EAAE,EAAA;AACtE,QAAA,MAAM,GAAG,GAAG,IAAI,WAAW,CAAC,IAAI,EAAE;AAChC,YAAA,OAAO,EAAE,IAAI;AACb,YAAA,UAAU,EAAE,IAAI;AAChB,YAAA,MAAM,EAAE;AACN,gBAAA,GAAG,MAAM;gBACT,IAAI,EAAE,IAAI,CAAC,EAAE;AACd,aAAA;AACF,SAAA,CAAC;AAEF,QAAA,IAAI,CAAC,EAAE,CAAC,aAAa,CAAC,GAAG,CAAC;;IAGpB,YAAY,CAAC,GAAU,EAAE,MAAmB,EAAA;AAClD,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS;AACxC,QAAA,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE;AACnC,YAAA,OAAO,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,CAAC,QAAQ,CAAC;;QAElF,OAAO,SAAS,IAAI,UAAU;;AAGxB,IAAA,eAAe,CAAC,MAA0B,EAAA;QAChD,OAAO,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,MAAM,KAAK,IAAI,CAAC,EAAE,CAAC;;IAG9D,OAAO,GAAA;QACZ,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC;;IAGtC,MAAM,CAAmC,IAAO,EAAE,KAA2B,EAAA;AAClF,QAAA,IAAI,KAAK,KAAK,SAAS,EAAE;AACvB,YAAA,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;;AAG3B,QAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,KAAK;AAC1B,QAAA,IAAI,IAAI,KAAK,OAAO,EAAE;YACpB,IAAI,CAAC,YAAY,EAAE;;AAErB,QAAA,OAAO,KAAK;;IAGP,OAAO,GAAA;AACZ,QAAA,OAAO,gBAAgB,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,oBAAoB,EAAE,EAAG,IAAI,CAAC,OAA4B,CAAC,UAAU,IAAI,SAAS,CAAC;;IAGpH,IAAI,CAAC,KAAe,EAAE,YAAsB,EAAA;QACjD,MAAM,KAAK,GAAmC,EAAE;AAChD,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,EAAE;QAEtB,IAAI,CAAC,OAAO,EAAE,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,CAAC,KAAI;YAC/B,MAAM,EAAE,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAgB;AAC5C,YAAA,IAAI,OAAO,CAAC,EAAE,EAAE,IAAI,CAAC,oBAAoB,EAAE,EAAE,MAAM,EAAE,KAAK,CAAC,EAAE;AAC3D,gBAAA,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE;;AAElB,SAAC,CAAC;AAEF,QAAA,YAAY,IAAI,IAAI,CAAC,qBAAqB,EAAE;AAE5C,QAAA,KAAK,CAAC,OAAO,CAAC,CAAC,EAAE,KAAI;AACnB,YAAA,IAAI,KAAK,CAAC,EAAE,CAAC,EAAE;gBACb,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;gBAC7B,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;;AAEjC,SAAC,CAAC;AAEF,QAAA,YAAY,IAAI,IAAI,CAAC,UAAU,EAAE;;;IAI5B,IAAI,GAAA;AACT,QAAA,MAAM,KAAK,GAAI,IAAI,CAAC,OAA4B,CAAC,KAAK;AACtD,QAAA,KAAK,EAAE,GAAG,GAAG,IAAI,CAAC;;;IAIb,qBAAqB,GAAA;AAC1B,QAAA,IAAI,CAAC,gBAAgB,CAAC,qBAAqB,EAAE;;AAGxC,IAAA,iBAAiB,CAAC,KAAsB,EAAA;AAC7C,QAAA,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,KAAK,CAAC;;AAGzC,IAAA,oBAAoB,CAAC,MAAmB,EAAA;AAC7C,QAAA,IAAI,CAAC,gBAAgB,CAAC,oBAAoB,CAAC,MAAM,CAAC;;AAG7C,IAAA,UAAU,CAAC,QAAqB,EAAA;AACrC,QAAA,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,QAAQ,CAAC;;AAGrC,IAAA,OAAO,CAAC,MAAmB,EAAE,WAAoB,EAAE,MAAe,EAAE,QAAgB,EAAA;AACzF,QAAA,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,QAAQ,CAAC;;AAG/D,IAAA,cAAc,CAAC,GAAuB,EAAA;AAC3C,QAAA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;;IAGd,oBAAoB,GAAA;AAC1B,QAAA,OAAQ,IAAI,CAAC,OAA4B,CAAC,SAAS;;IAG7C,YAAY,GAAA;AAClB,QAAA,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO;AAE5B,QAAA,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE;YAClB,OAAO,CAAC,KAAK,GAAG;AACd,gBAAA,IAAI,EAAE,SAAS;AACf,gBAAA,IAAI,EAAE,IAAI;AACV,gBAAA,GAAG,EAAE,IAAI;AACT,gBAAA,WAAW,EAAE,KAAK;aACnB;;AAGH,QAAA,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,QAAQ,EAAE;YACrC,OAAO,CAAC,KAAK,GAAG,EAAE,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE;;AAGzC,QAAA,MAAM,KAAK,GAAG,OAAO,CAAC,KAKrB;QAED,IAAI,CAAC,eAAe,GAAG;AACrB,YAAA,IAAI,EAAE,KAAK,CAAC,IAAI,IAAI,IAAI;YACxB,SAAS,EAAE,CAAC,EAAa,EAAE,IAAe,EAAE,MAAmB,EAAE,GAAU,KAAuB;gBAChG,IAAI,CAAC,KAAK,CAAC,IAAI;AAAE,oBAAA,OAAO,KAAK;AAC7B,gBAAA,IAAI,OAAO,KAAK,CAAC,IAAI,KAAK,UAAU,EAAE;AACpC,oBAAA,OAAO,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,CAAC;;gBAE1C,OAAO,KAAK,CAAC,IAAI;aAClB;YACD,QAAQ,EAAE,CAAC,EAAa,EAAE,IAAe,EAAE,MAAmB,EAAE,GAAU,KAAa;gBACrF,IAAI,CAAC,KAAK,CAAC,GAAG;AAAE,oBAAA,OAAO,KAAK;gBAC5B,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;AAC5B,oBAAA,MAAM,SAAS,GAAI,IAAiB,CAAC,eAAe;AACpD,oBAAA,OAAO,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC;;AAElD,gBAAA,IAAI,OAAO,KAAK,CAAC,GAAG,KAAK,UAAU,EAAE;AACnC,oBAAA,OAAO,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,CAAC;;AAEzC,gBAAA,OAAO,CAAC,CAAC,KAAK,CAAC,GAAG;aACnB;AACD,YAAA,WAAW,EAAE,KAAK,CAAC,WAAW,IAAI,KAAK;SACxC;;QAGD,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU,EAAE,MAAK;AAC9D,YAAA,IAAI,CAAC,eAAe,GAAG,IAAI;AAC7B,SAAC,CAAC;;;;;;"}