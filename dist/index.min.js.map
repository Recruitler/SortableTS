{"version":3,"file":"index.min.js","sources":["../src/utils/touch.ts","../src/cleanup.manager.ts","../src/core/state.ts","../src/dom/dom.utils.ts","../src/animation/animation.utils.ts","../src/animation/animation.ts","../src/utils/array.ts","../src/utils/element.ts","../src/utils/scroll.ts","../src/core/sortable.ts"],"sourcesContent":["import { ISortableDOMEvents } from '@/dom/event.interfaces';\nimport { ICoordinates } from '@/global.interfaces';\n\n/**\n * Type guards for event types\n */\nexport function isTouchEvent(evt: Event): evt is TouchEvent {\n  return 'touches' in evt;\n}\n\nexport function isPointerEvent(evt: Event): evt is PointerEvent {\n  return 'pointerType' in evt;\n}\n\n/**\n * Extract touch information from various event types\n * @param evt - Mouse, Touch, or Pointer event\n * @returns Touch object, PointerEvent, or null if no touch data available\n */\nexport function getTouchFromEvent(evt: ISortableDOMEvents): Touch | PointerEvent | null {\n  if (isTouchEvent(evt) && evt.touches[0]) {\n    return evt.touches[0];\n  } else if (isPointerEvent(evt) && evt.pointerType === 'touch') {\n    return evt;\n  }\n  return null;\n}\n\n/**\n * Extract coordinates from any supported event type\n * @param evt - Mouse, Touch, or Pointer event\n * @returns Coordinates object or null if no coordinate data available\n */\nexport function getEventCoordinates(evt: ISortableDOMEvents): ICoordinates | null {\n  const touch = getTouchFromEvent(evt);\n  if (touch) {\n    return {\n      clientX: touch.clientX,\n      clientY: touch.clientY,\n    };\n  }\n\n  // Handle non-touch mouse/pointer events\n  if ('clientX' in evt) {\n    return {\n      clientX: evt.clientX,\n      clientY: evt.clientY,\n    };\n  }\n\n  return null;\n}\n","import { ISortableDOMEventListener } from '@dom/event.interfaces';\n\ninterface ICaptureMode {\n  capture: boolean;\n  passive: boolean;\n}\n\nconst captureMode: ICaptureMode = {\n  capture: false,\n  passive: false,\n};\n\ninterface ICleanupTask {\n  type: 'event' | 'timer' | 'animation' | 'custom';\n  cleanup: () => void;\n}\n\nexport class CleanupManager {\n  private tasks: Map<symbol, Set<ICleanupTask>> = new Map();\n  private static instance: CleanupManager;\n\n  private constructor() {}\n\n  public static getInstance(): CleanupManager {\n    if (!CleanupManager.instance) {\n      CleanupManager.instance = new CleanupManager();\n    }\n    return CleanupManager.instance;\n  }\n\n  private removeEventListener(el: HTMLElement | Document, event: string, fn: ISortableDOMEventListener): void {\n    el.removeEventListener(event, fn as EventListener, captureMode);\n  }\n\n  public registerEventListener(instanceId: symbol, element: HTMLElement | Document, event: string, handler: ISortableDOMEventListener): void {\n    element.addEventListener(event, handler as EventListener, captureMode);\n    this.addTask(instanceId, {\n      type: 'event',\n      cleanup: () => this.removeEventListener(element, event, handler),\n    });\n  }\n\n  public registerTimer(instanceId: symbol, timerId: number): void {\n    this.addTask(instanceId, {\n      type: 'timer',\n      cleanup: () => clearTimeout(timerId),\n    });\n  }\n\n  public registerAnimationCleanup(instanceId: symbol, cleanup: () => void): void {\n    this.addTask(instanceId, {\n      type: 'animation',\n      cleanup,\n    });\n  }\n\n  public registerCustomCleanup(instanceId: symbol, cleanup: () => void): void {\n    this.addTask(instanceId, {\n      type: 'custom',\n      cleanup,\n    });\n  }\n\n  private addTask(instanceId: symbol, task: ICleanupTask): void {\n    if (!this.tasks.has(instanceId)) {\n      this.tasks.set(instanceId, new Set());\n    }\n    this.tasks.get(instanceId)!.add(task);\n  }\n\n  public cleanup(instanceId: symbol): void {\n    const tasks = this.tasks.get(instanceId);\n    if (!tasks) return;\n\n    // Execute all cleanup tasks\n    tasks.forEach((task) => task.cleanup());\n\n    // Clear tasks for this instance\n    this.tasks.delete(instanceId);\n  }\n\n  public cleanupAll(): void {\n    this.tasks.forEach((_tasks: Set<ICleanupTask>, instanceId: symbol) => {\n      this.cleanup(instanceId);\n    });\n    this.tasks.clear();\n  }\n}\n","import { ISortableDOMEvents } from '@/dom/event.interfaces';\nimport { CleanupManager } from '../cleanup.manager';\nimport { getTouchFromEvent } from '../utils/touch';\nimport { ISortable } from './sortable.interfaces';\n\n// Symbol-based instance key\nexport const SORTABLE_INSTANCE_KEY = Symbol('SortableInstance');\n\nexport interface SortableElement extends HTMLElement {\n  [SORTABLE_INSTANCE_KEY]?: ISortable;\n}\n\nexport interface DragState {\n  active: boolean;\n  sourceEl: HTMLElement | null;\n  dragEl: HTMLElement | null;\n  ghostEl: HTMLElement | null;\n  cloneEl: HTMLElement | null;\n  parentEl: HTMLElement | null;\n  nextEl: HTMLElement | null;\n  lastDownEl: HTMLElement | null;\n  oldIndex: number | null;\n  newIndex: number | null;\n  oldDraggableIndex: number | null;\n  newDraggableIndex: number | null;\n  moved: boolean;\n  position: {\n    clientX: number;\n    clientY: number;\n    initialX: number;\n    initialY: number;\n    dx: number;\n    dy: number;\n  };\n}\n\nexport interface GlobalState {\n  activeSortable: ISortable | null;\n  dragOperation: DragState;\n  instances: Map<HTMLElement, ISortable>;\n}\n\ntype StateChangeListener = (state: Readonly<GlobalState>) => void;\n\nexport class SortableState {\n  private static instance: SortableState;\n  private state: GlobalState;\n  private listeners: Set<StateChangeListener> = new Set();\n  private cleanupManager: CleanupManager;\n\n  private constructor() {\n    this.state = {\n      activeSortable: null,\n      instances: new Map(),\n      dragOperation: {\n        active: false,\n        sourceEl: null,\n        dragEl: null,\n        ghostEl: null,\n        cloneEl: null,\n        parentEl: null,\n        nextEl: null,\n        lastDownEl: null,\n        oldIndex: null,\n        newIndex: null,\n        oldDraggableIndex: null,\n        newDraggableIndex: null,\n        moved: false,\n        position: {\n          clientX: 0,\n          clientY: 0,\n          initialX: 0,\n          initialY: 0,\n          dx: 0,\n          dy: 0,\n        },\n      },\n    };\n    this.cleanupManager = CleanupManager.getInstance();\n  }\n\n  public static getInstance(): SortableState {\n    if (!SortableState.instance) {\n      SortableState.instance = new SortableState();\n    }\n    return SortableState.instance;\n  }\n\n  // Enhanced instance management with Symbol-based element binding\n  public registerInstance(el: HTMLElement, instance: ISortable): void {\n    if (this.state.instances.has(el)) {\n      throw new Error('Instance already registered for element');\n    }\n    this.state.instances.set(el, instance);\n    (el as SortableElement)[SORTABLE_INSTANCE_KEY] = instance;\n    this.notifyListeners();\n  }\n\n  public destroyInstance(instanceId: symbol): void {\n    // Execute all cleanup tasks\n    this.cleanupManager.cleanup(instanceId);\n\n    // Find and remove instance from state tracking\n    let elementToRemove: HTMLElement | null = null;\n    this.state.instances.forEach((instance, el) => {\n      if ((instance as any).instanceId === instanceId) {\n        elementToRemove = el;\n      }\n    });\n\n    if (elementToRemove) {\n      this.removeInstance(elementToRemove);\n    }\n  }\n\n  public removeInstance(el: HTMLElement): void {\n    this.state.instances.delete(el);\n    delete (el as SortableElement)[SORTABLE_INSTANCE_KEY];\n    this.notifyListeners();\n  }\n\n  public getInstance(el: HTMLElement): ISortable | undefined {\n    // First try Map-based lookup\n    const instance = this.state.instances.get(el);\n    if (instance) return instance;\n\n    // Fallback to Symbol-based lookup\n    return (el as SortableElement)[SORTABLE_INSTANCE_KEY];\n  }\n\n  // State subscription management\n  public subscribe(listener: StateChangeListener): () => void {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  private notifyListeners(): void {\n    const state = this.getState();\n    this.listeners.forEach((listener) => listener(state));\n  }\n\n  // Immutable state access\n  public getState(): Readonly<GlobalState> {\n    return Object.freeze({ ...this.state });\n  }\n\n  // Drag operation state management\n  public startDrag(sourceEl: HTMLElement, clientX: number = 0, clientY: number = 0): void {\n    if (this.state.dragOperation.active) {\n      throw new Error('Drag operation already in progress');\n    }\n\n    const sortable = this.getInstance(sourceEl);\n    if (!sortable) {\n      throw new Error('No sortable instance found for element');\n    }\n\n    this.state.activeSortable = sortable;\n    this.state.dragOperation = {\n      ...this.state.dragOperation,\n      active: true,\n      sourceEl,\n      oldIndex: this.getElementIndex(sourceEl),\n      position: {\n        clientX,\n        clientY,\n        initialX: clientX,\n        initialY: clientY,\n        dx: 0,\n        dy: 0,\n      },\n    };\n    this.notifyListeners();\n  }\n\n  public updateDragPosition(clientX: number, clientY: number): void {\n    const oldPos = this.state.dragOperation.position;\n    this.state.dragOperation.position = {\n      clientX,\n      clientY,\n      initialX: oldPos.initialX,\n      initialY: oldPos.initialY,\n      dx: clientX - oldPos.clientX,\n      dy: clientY - oldPos.clientY,\n    };\n    this.notifyListeners();\n  }\n\n  public updateDragElements(elements: Partial<Pick<DragState, 'dragEl' | 'ghostEl' | 'cloneEl' | 'parentEl' | 'nextEl' | 'oldIndex' | 'moved'>>): void {\n    this.state.dragOperation = {\n      ...this.state.dragOperation,\n      ...elements,\n    };\n    this.notifyListeners();\n  }\n\n  public endDrag(): void {\n    this.state.activeSortable = null;\n    this.state.dragOperation = {\n      ...this.state.dragOperation,\n      active: false,\n      sourceEl: null,\n      dragEl: null,\n      ghostEl: null,\n      cloneEl: null,\n      oldIndex: null,\n      newIndex: null,\n    };\n    this.notifyListeners();\n  }\n\n  public updateScrollPosition(scrollTop: number, scrollLeft: number): void {\n    // Update scroll position in state\n    this.state.dragOperation.position = {\n      ...this.state.dragOperation.position,\n      dx: this.state.dragOperation.position.dx + scrollLeft,\n      dy: this.state.dragOperation.position.dy + scrollTop,\n    };\n    this.notifyListeners();\n  }\n\n  // Element detection during drag\n  public getElementFromPoint(x: number, y: number): HTMLElement | null {\n    const dragEl = this.state.dragOperation.dragEl;\n    if (dragEl) {\n      const prevDisplay = dragEl.style.display;\n      dragEl.style.display = 'none';\n      const element = document.elementFromPoint(x, y) as HTMLElement | null;\n      dragEl.style.display = prevDisplay;\n      return element;\n    }\n    return document.elementFromPoint(x, y) as HTMLElement | null;\n  }\n\n  // Event target resolution with shadow DOM support\n  public getEventTarget(evt: Event): HTMLElement | null {\n    const { target } = evt;\n    if (!(target instanceof HTMLElement)) return null;\n\n    if (target.shadowRoot) {\n      const touch = getTouchFromEvent(evt as ISortableDOMEvents);\n      if (touch) {\n        const shadowTarget = target.shadowRoot.elementFromPoint(touch.clientX, touch.clientY);\n        if (shadowTarget instanceof HTMLElement) {\n          return shadowTarget;\n        }\n      }\n    }\n\n    return target;\n  }\n\n  // Utility methods\n  private getElementIndex(el: HTMLElement): number {\n    return Array.from(el.parentElement?.children || []).indexOf(el);\n  }\n\n  // Getters for specific state slices\n  public getActiveSortable(): ISortable | null {\n    return this.state.activeSortable;\n  }\n\n  public getDragOperation(): Readonly<DragState> {\n    return Object.freeze({ ...this.state.dragOperation });\n  }\n\n  // Instance validation\n  public hasInstance(el: HTMLElement): boolean {\n    return this.state.instances.has(el) || SORTABLE_INSTANCE_KEY in el;\n  }\n\n  // Debug helper\n  public getInstanceCount(): number {\n    return this.state.instances.size;\n  }\n\n  // Cleanup utility\n  public reset(): void {\n    this.state.instances.forEach((_, el) => this.removeInstance(el));\n    this.endDrag();\n    this.listeners.clear();\n  }\n}\n","import { IMatrix } from '@core/sortable.interfaces';\n\nconst captureMode = {\n  capture: false,\n  passive: false,\n} as const;\n\nexport const addEvent = (el: HTMLElement, event: string, fn: (evt: Event) => void): void => {\n  el.addEventListener(event, fn, captureMode);\n};\n\nexport const removeEvent = (el: HTMLElement, event: string, fn: (evt: Event) => void): void => {\n  el.removeEventListener(event, fn, captureMode);\n};\n\nexport const matches = (el: HTMLElement | null, selector: string): boolean => {\n  if (!selector || !el) return false;\n\n  if (selector[0] === '>') {\n    selector = selector.substring(1);\n  }\n\n  try {\n    return el.matches?.(selector) || false;\n  } catch {\n    return false;\n  }\n};\n\nexport const getParentOrHost = (el: Node): Node => ((el as any).host && el !== document && (el as any).host.nodeType ? (el as any).host : (el.parentNode as Node));\n\nexport const closest = (el: HTMLElement | null, selector: string, ctx: Node = document, includeCTX = false): HTMLElement | null => {\n  if (!el) return null;\n\n  let current: Node | null = el;\n  do {\n    if ((selector != null && (selector[0] === '>' ? current.parentNode === ctx && matches(current as HTMLElement, selector) : matches(current as HTMLElement, selector))) || (includeCTX && current === ctx)) {\n      return current as HTMLElement;\n    }\n\n    if (current === ctx) break;\n  } while ((current = getParentOrHost(current)));\n\n  return null;\n};\n\nexport const toggleClass = (el: HTMLElement, name: string, state: boolean): void => {\n  if (!el || !name) return;\n  el.classList?.[state ? 'add' : 'remove'](name);\n};\n\nexport type CSSProperties = Partial<CSSStyleDeclaration>;\n\nexport const css = (el: HTMLElement, prop: string | CSSProperties, val?: string | number): string | void => {\n  if (!el?.style) return;\n\n  if (typeof prop === 'object') {\n    Object.entries(prop).forEach(([key, value]) => {\n      if (!(key in el.style) && !key.startsWith('webkit')) {\n        key = `-webkit-${key}`;\n      }\n      el.style[key as any] = `${value}${typeof value === 'string' ? '' : 'px'}`;\n    });\n    return;\n  }\n\n  if (val === undefined) {\n    return getComputedStyle(el)[prop as any];\n  }\n\n  if (!(prop in el.style) && !prop.startsWith('webkit')) {\n    prop = `-webkit-${prop}`;\n  }\n\n  el.style[prop as any] = `${val}${typeof val === 'string' ? '' : 'px'}`;\n};\n\nexport const matrix = (el: HTMLElement | string, selfOnly = false): IMatrix | null => {\n  let transforms = '';\n\n  if (typeof el === 'string') {\n    transforms = el;\n  } else {\n    let current: HTMLElement | null = el;\n    do {\n      const transform = css(current, 'transform');\n      if (transform && transform !== 'none') {\n        transforms = `${transform} ${transforms}`;\n      }\n    } while (!selfOnly && (current = current.parentElement));\n  }\n\n  const MatrixConstructor = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;\n  return MatrixConstructor ? (new MatrixConstructor(transforms) as IMatrix) : null;\n};\n\nexport const getRect = (el: HTMLElement | Window, relativeToContainingBlock = false, relativeToNonStaticParent = false, undoScale = false, container?: HTMLElement): DOMRect => {\n  if (el === window) {\n    return {\n      top: 0,\n      left: 0,\n      bottom: window.innerHeight,\n      right: window.innerWidth,\n      width: window.innerWidth,\n      height: window.innerHeight,\n      x: 0,\n      y: 0,\n      toJSON() {\n        return {\n          x: this.x,\n          y: this.y,\n          top: this.top,\n          right: this.right,\n          bottom: this.bottom,\n          left: this.left,\n          width: this.width,\n          height: this.height,\n        };\n      },\n    } as DOMRect;\n  }\n\n  const elRect = (el as HTMLElement).getBoundingClientRect();\n  let top = elRect.top;\n  let left = elRect.left;\n  let bottom = elRect.bottom;\n  let right = elRect.right;\n  let { width, height } = elRect;\n\n  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {\n    container = container || ((el as HTMLElement).parentNode as HTMLElement);\n\n    do {\n      if (container?.getBoundingClientRect && (css(container, 'transform') !== 'none' || (relativeToNonStaticParent && css(container, 'position') !== 'static'))) {\n        const containerRect = container.getBoundingClientRect();\n        const borderTop = parseInt(css(container, 'border-top-width') as string) || 0;\n        const borderLeft = parseInt(css(container, 'border-left-width') as string) || 0;\n\n        top -= containerRect.top + borderTop;\n        left -= containerRect.left + borderLeft;\n        bottom = top + elRect.height;\n        right = left + elRect.width;\n        break;\n      }\n    } while ((container = container.parentNode as HTMLElement));\n  }\n\n  if (undoScale && el !== window) {\n    const elMatrix = matrix(container || (el as HTMLElement));\n    if (elMatrix) {\n      const { a: scaleX, d: scaleY } = elMatrix;\n      top /= scaleY;\n      left /= scaleX;\n      width /= scaleX;\n      height /= scaleY;\n      bottom = top + height;\n      right = left + width;\n    }\n  }\n\n  return {\n    top,\n    left,\n    bottom,\n    right,\n    width,\n    height,\n    x: left,\n    y: top,\n    toJSON() {\n      return {\n        x: this.x,\n        y: this.y,\n        top: this.top,\n        right: this.right,\n        bottom: this.bottom,\n        left: this.left,\n        width: this.width,\n        height: this.height,\n      };\n    },\n  } as DOMRect;\n};\n\nexport const getScrollingElement = (): HTMLElement => (document.scrollingElement as HTMLElement) || document.documentElement;\n\nexport const clone = <T extends Node>(el: T): T => el.cloneNode(true) as T;\n","import type { ISortableOptions } from '@core/sortable.interfaces';\nimport { css, matrix } from '@dom/dom.utils';\n\n/**\n * Checks if two DOMRects are equal within rounding tolerance\n */\nexport const isRectEqual = (rect1: DOMRect, rect2: DOMRect): boolean => {\n  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);\n};\n\n/**\n * Calculates the real animation time based on movement distances\n */\nexport const calculateRealTime = (animatingRect: DOMRect, fromRect: DOMRect, toRect: DOMRect, options: ISortableOptions): number => {\n  const dx1 = Math.pow(fromRect.top - animatingRect.top, 2);\n  const dy1 = Math.pow(fromRect.left - animatingRect.left, 2);\n  const dx2 = Math.pow(fromRect.top - toRect.top, 2);\n  const dy2 = Math.pow(fromRect.left - toRect.left, 2);\n\n  return (Math.sqrt(dx1 + dy1) / Math.sqrt(dx2 + dy2)) * (options.animation || 0);\n};\n\n/**\n * Forces a browser repaint by accessing offsetWidth\n */\nexport const forceRepaint = (target: HTMLElement): number => target.offsetWidth;\n\n/**\n * Animate an element from one position to another using transforms\n */\nexport const animate = (target: HTMLElement, currentRect: DOMRect, toRect: DOMRect, duration: number, options: ISortableOptions): void => {\n  if (!duration) return;\n\n  // Clear existing transitions and transforms\n  css(target, 'transition', '');\n  css(target, 'transform', '');\n\n  // Calculate scaling\n  const elMatrix = matrix(target);\n  const scaleX = elMatrix?.a || 1;\n  const scaleY = elMatrix?.d || 1;\n\n  // Calculate translation distances\n  const translateX = (currentRect.left - toRect.left) / scaleX;\n  const translateY = (currentRect.top - toRect.top) / scaleY;\n\n  // Set animation flags\n  target.animatingX = !!translateX;\n  target.animatingY = !!translateY;\n\n  // Apply initial transform\n  css(target, 'transform', `translate3d(${translateX}px,${translateY}px,0)`);\n\n  // Force repaint before transition\n  forceRepaint(target);\n\n  // Start animation\n  css(target, 'transition', `transform ${duration}ms${options.easing ? ' ' + options.easing : ''}`);\n  css(target, 'transform', 'translate3d(0,0,0)');\n\n  // Clear previous animation timeout\n  if (target.animated) {\n    clearTimeout(target.animated as number);\n  }\n\n  // Set cleanup timeout\n  target.animated = window.setTimeout(() => {\n    css(target, 'transition', '');\n    css(target, 'transform', '');\n    target.animated = false;\n    target.animatingX = false;\n    target.animatingY = false;\n  }, duration) as unknown as number;\n};\n","import { ISortable } from '@core/sortable.interfaces';\nimport { SortableState } from '@core/state';\nimport { css, getRect } from '@dom/dom.utils';\nimport { indexOfObject } from '@utils/array';\nimport { CleanupManager } from '../cleanup.manager';\nimport { IAnimationManager, IAnimationState } from './animation.interfaces';\nimport { animate as animateElement, calculateRealTime, isRectEqual } from './animation.utils';\n\n/**\n * Manages animation states and transitions for sortable elements\n */\nexport class AnimationStateManager implements IAnimationManager {\n  private animationStates: IAnimationState[] = [];\n  private animationCallbackId?: number;\n  private sortable: ISortable;\n  private state: SortableState;\n  private cleanupManager: CleanupManager;\n  private instanceId: symbol;\n\n  constructor(sortable: ISortable) {\n    this.sortable = sortable;\n    this.state = SortableState.getInstance();\n    this.cleanupManager = CleanupManager.getInstance();\n    this.instanceId = Symbol('AnimationStateManager');\n  }\n\n  /**\n   * Captures the current state of all animated children\n   */\n  public captureAnimationState(): void {\n    this.animationStates = [];\n    if (!this.sortable.options.animation) return;\n\n    const dragState = this.state.getDragOperation();\n    const children = Array.from(this.sortable.el.children);\n\n    children.forEach((child) => {\n      if (!(child instanceof HTMLElement)) return;\n      if (css(child, 'display') === 'none' || child === dragState.ghostEl) return;\n\n      const state: IAnimationState = {\n        target: child,\n        rect: getRect(child),\n      };\n\n      this.animationStates.push(state);\n\n      // Store original rect for reference\n      const fromRect = { ...state.rect };\n\n      // Compensate for ongoing animations\n      if (child.thisAnimationDuration) {\n        this.compensateForAnimation(child, fromRect);\n      }\n\n      child.fromRect = fromRect;\n    });\n  }\n\n  /**\n   * Adds a new animation state to track\n   */\n  public addAnimationState(state: IAnimationState): void {\n    this.animationStates.push(state);\n  }\n\n  /**\n   * Removes an animation state for a specific target\n   */\n  public removeAnimationState(target: HTMLElement): void {\n    const index = indexOfObject(this.animationStates, { target });\n    if (index !== -1) {\n      this.animationStates.splice(index, 1);\n    }\n  }\n\n  /**\n   * Animates all tracked states\n   */\n  public animateAll(callback?: () => void): void {\n    if (!this.sortable.options.animation) {\n      this.clearAnimation(callback);\n      return;\n    }\n\n    const { animating, maxDuration } = this.processAnimationStates();\n\n    this.scheduleCallback(animating, maxDuration, callback);\n    this.animationStates = [];\n  }\n\n  /**\n   * Animate a single element\n   */\n  public animate(target: HTMLElement, currentRect: DOMRect, toRect: DOMRect, duration: number): void {\n    animateElement(target, currentRect, toRect, duration, this.sortable.options);\n  }\n\n  /**\n   * Compensates for any existing CSS transform matrix by adjusting the position coordinates of a DOMRect.\n   * This is useful when you need the true position of an element ignoring its current transform.\n   * @param element - The HTML element to check for transform matrix\n   * @param rect - The original DOMRect to adjust\n   * @returns A new DOMRect with position adjusted for transform matrix, or the original rect if no transform exists\n   */\n  private compensateForAnimation(element: HTMLElement, rect: DOMRect): DOMRect {\n    const computedMatrix: string = getComputedStyle(element).transform;\n    if (computedMatrix && computedMatrix !== 'none') {\n      const matrix: DOMMatrix = new DOMMatrix(computedMatrix);\n      // Create a mutable copy of the rect properties\n      return new DOMRect(\n        rect.x - matrix.m41, // Adjust x/left\n        rect.y - matrix.m42, // Adjust y/top\n        rect.width,\n        rect.height\n      );\n    }\n    return rect;\n  }\n\n  /**\n   * Process all animation states and calculate timings\n   */\n  private processAnimationStates(): { animating: boolean; maxDuration: number } {\n    let animating = false;\n    let maxDuration = 0;\n\n    this.animationStates.forEach((state) => {\n      const duration = this.calculateAnimationDuration(state);\n      if (duration) {\n        animating = true;\n        maxDuration = Math.max(maxDuration, duration);\n        this.setupAnimationReset(state.target, duration);\n      }\n    });\n\n    return { animating, maxDuration };\n  }\n\n  /**\n   * Calculates the appropriate animation duration for a state transition.\n   * If there's an ongoing animation, it may calculate real-time duration based on previous positions.\n   * Otherwise, it uses the default animation duration from options.\n   *\n   * @param state - The animation state containing target and position information\n   * @returns The calculated animation duration in milliseconds\n   */\n  private calculateAnimationDuration(state: IAnimationState): number {\n    const { target } = state;\n    const currentRect: DOMRect = getRect(target);\n    let duration: number = 0;\n\n    // If there's an ongoing animation, check if we need to calculate real-time duration\n    if (target.thisAnimationDuration && target.prevFromRect && target.prevToRect && isRectEqual(target.prevFromRect, currentRect)) {\n      duration = calculateRealTime(state.rect, target.prevFromRect, target.prevToRect, this.sortable.options);\n    }\n\n    // If the position has changed from the initial position\n    if (target.fromRect && !isRectEqual(currentRect, target.fromRect)) {\n      // Update tracking for the next animation frame\n      this.updateAnimationTracking(target, currentRect);\n\n      // Use default animation duration if real-time duration wasn't calculated\n      if (!duration) {\n        duration = this.sortable.options.animation || 0;\n      }\n\n      this.animate(target, state.rect, currentRect, duration);\n    }\n\n    return duration;\n  }\n\n  /**\n   * Determine if we should calculate real duration based on previous states\n   */\n  // private shouldCalculateRealDuration(target: HTMLElement, currentRect: DOMRect): boolean {\n  //   return target.prevFromRect && target.prevToRect && isRectEqual(target.prevFromRect, currentRect) && !isRectEqual(target.fromRect!, currentRect);\n  // }\n\n  /**\n   * Update animation tracking state for an element\n   */\n  private updateAnimationTracking(target: HTMLElement, currentRect: DOMRect): void {\n    target.prevFromRect = target.fromRect!;\n    target.prevToRect = currentRect;\n  }\n\n  /**\n   * Setup animation reset timer for an element\n   */\n  private setupAnimationReset(target: HTMLElement, duration: number): void {\n    if (target.animationResetTimer) {\n      clearTimeout(target.animationResetTimer);\n    }\n\n    target.animationResetTimer = window.setTimeout(() => {\n      target.animationTime = 0;\n      target.prevFromRect = null;\n      target.fromRect = null;\n      target.prevToRect = null;\n      target.thisAnimationDuration = null;\n      target.animationResetTimer = undefined;\n    }, duration);\n\n    // Register timer for cleanup\n    this.cleanupManager.registerTimer(this.instanceId, target.animationResetTimer);\n    target.thisAnimationDuration = duration;\n  }\n\n  /**\n   * Schedule the animation callback\n   */\n  private scheduleCallback(animating: boolean, duration: number, callback?: () => void): void {\n    if (this.animationCallbackId) {\n      clearTimeout(this.animationCallbackId);\n    }\n\n    if (!animating) {\n      callback?.();\n      return;\n    }\n\n    this.animationCallbackId = window.setTimeout(() => {\n      callback?.();\n      this.animationCallbackId = undefined;\n    }, duration);\n\n    // Register timer for cleanup\n    if (this.animationCallbackId) {\n      this.cleanupManager.registerTimer(this.instanceId, this.animationCallbackId);\n    }\n  }\n\n  /**\n   * Clear animation state and execute callback\n   */\n  private clearAnimation(callback?: () => void): void {\n    clearTimeout(this.animationCallbackId);\n    callback?.();\n  }\n\n  public destroy(): void {\n    // The cleanupManager.cleanup will handle all timer cleanup\n    this.cleanupManager.cleanup(this.instanceId);\n  }\n}\n","/**\n * Returns the index of an object in an array by matching object properties\n * @param arr Array to search in\n * @param obj Object with properties to match\n * @returns Index of the first matching object, or -1 if not found\n */\nexport function indexOfObject<T extends object>(arr: T[], obj: Partial<T>): number {\n  for (let i = 0; i < arr.length; i++) {\n    const matches = Object.keys(obj).every((key) => {\n      return obj[key as keyof T] === arr[i][key as keyof T];\n    });\n\n    if (matches) return i;\n  }\n  return -1;\n}\n\n/**\n * Moves an item from one position in array to another\n */\nexport function arrayMove<T>(arr: T[], previousIndex: number, newIndex: number): T[] {\n  const array = arr.slice(0);\n  if (newIndex >= array.length) {\n    let k = newIndex - array.length;\n    while (k-- + 1) {\n      array.push(undefined as any);\n    }\n  }\n  array.splice(newIndex, 0, array.splice(previousIndex, 1)[0]);\n  return array;\n}\n\n/**\n * Swaps two elements in an array\n */\nexport function swap<T>(arr: T[], i: number, j: number): void {\n  [arr[i], arr[j]] = [arr[j], arr[i]];\n}\n","import { closest } from '@dom/dom.utils';\n\n/**\n * Generates a unique identifier for an HTML element based on its properties\n * @param element The HTML element to generate an ID for\n * @returns A string hash of the element's properties\n */\nexport function generateElementId(element: HTMLElement): string {\n  // Get element properties safely with type checking\n  const properties: string[] = [element.tagName || '', element.className || '', (element as HTMLImageElement).src || '', (element as HTMLAnchorElement).href || '', element.textContent || ''];\n\n  // Join all properties and generate hash\n  const str = properties.join('_');\n  let hash = 0;\n\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n\n  return Math.abs(hash).toString(36);\n}\n\n/**\n * Gets an array of element IDs from a container based on a draggable selector\n * @param container The container element to search within\n * @param draggableSelector The selector to identify draggable elements\n * @param dataIdAttr The attribute to use for element IDs\n * @returns Array of element IDs\n */\nexport function getElementsArray(container: HTMLElement, draggableSelector: string, dataIdAttr: string): string[] {\n  const order: string[] = [];\n  const children = container.children;\n\n  for (let i = 0; i < children.length; i++) {\n    const el = children[i] as HTMLElement;\n    if (closest(el, draggableSelector, container, false)) {\n      order.push(el.getAttribute(dataIdAttr) || generateElementId(el));\n    }\n  }\n\n  return order;\n}\n","/**\n * Check if an element is scrollable\n */\nexport const isScrollable = (el: HTMLElement): boolean => {\n  const computedStyle = window.getComputedStyle(el);\n  const overflowY = computedStyle.overflowY;\n  const overflowX = computedStyle.overflowX;\n\n  return /auto|scroll|overlay|hidden/.test(overflowY) || /auto|scroll|overlay|hidden/.test(overflowX);\n};\n\n/**\n * Get the closest scrollable parent of an element\n * @param el Element to find scrollable parent for\n * @param includeHidden Whether to include elements with overflow: hidden\n * @returns The closest scrollable parent element or null if none found\n */\nexport const getScrollParent = (el: HTMLElement, includeHidden: boolean = false): HTMLElement | null => {\n  let style: CSSStyleDeclaration;\n\n  // Skip if element is not valid\n  if (!el || !el.parentElement) {\n    return null;\n  }\n\n  let parent: HTMLElement | null = el.parentElement;\n\n  while (parent) {\n    style = window.getComputedStyle(parent);\n    const overflow = style.overflow + style.overflowY + style.overflowX;\n\n    // Check if parent is scrollable\n    if (/auto|scroll|overlay/.test(overflow) || (includeHidden && overflow.includes('hidden'))) {\n      return parent;\n    }\n\n    parent = parent.parentElement;\n  }\n\n  // If no scrollable parent found, return document.scrollingElement or body\n  return (document.scrollingElement as HTMLElement) || document.documentElement;\n};\n\n/**\n * Get all scrolling ancestors of an element\n */\nexport const getScrollingAncestors = (el: HTMLElement): HTMLElement[] => {\n  const ancestors: HTMLElement[] = [];\n  let parent = getScrollParent(el);\n\n  while (parent) {\n    ancestors.push(parent);\n    parent = getScrollParent(parent);\n  }\n\n  return ancestors;\n};\n\n/**\n * Get scroll position of an element\n */\nexport const getScroll = (el: HTMLElement | Window): { scrollTop: number; scrollLeft: number } => {\n  if (el === window) {\n    return {\n      scrollTop: window.pageYOffset || document.documentElement.scrollTop,\n      scrollLeft: window.pageXOffset || document.documentElement.scrollLeft,\n    };\n  }\n\n  return {\n    scrollTop: (el as HTMLElement).scrollTop,\n    scrollLeft: (el as HTMLElement).scrollLeft,\n  };\n};\n","import { ISortableDOMEventListener, ISortableDOMEvents } from '@/dom/event.interfaces';\nimport { getEventCoordinates, getTouchFromEvent } from '@/utils/touch';\nimport { AnimationStateManager } from '@animation/animation';\nimport { IAnimationState } from '@animation/animation.interfaces';\nimport { ISortable, ISortableGroup, ISortableOptions, SortableDirection } from '@core/sortable.interfaces';\nimport { closest, css, getRect, matrix, toggleClass } from '@dom/dom.utils';\nimport { getElementsArray } from '@utils/element';\nimport { getScroll, getScrollParent } from '@utils/scroll';\nimport { CleanupManager } from '../cleanup.manager';\nimport { DragState, SortableState } from './state';\n\nexport class Sortable implements ISortable {\n  private static defaultOptions: ISortableOptions = {\n    group: null,\n    sort: true,\n    disabled: false,\n    store: null,\n    handle: null,\n    draggable: '>*',\n    swapThreshold: 1,\n    invertSwap: false,\n    invertedSwapThreshold: null,\n    removeCloneOnHide: true,\n    direction: 'vertical',\n    draggingClass: 'sortable-dragging',\n    chosenClass: 'sortable-chosen',\n    dragClass: 'sortable-drag',\n    ignore: 'a, img',\n    filter: null,\n    preventOnFilter: true,\n    animation: 0,\n    easing: null,\n    setData: function (dataTransfer: DataTransfer, activeEl: HTMLElement) {\n      dataTransfer.setData('Text', activeEl.textContent || '');\n    },\n    dropBubble: false,\n    dragoverBubble: false,\n    dataIdAttr: 'data-id',\n    delay: 0,\n    touchStartThreshold: 1,\n    forceFallback: false,\n    fallbackClass: 'sortable-fallback',\n    fallbackOnBody: false,\n    fallbackTolerance: 0,\n    fallbackOffset: { x: 0, y: 0 },\n    supportPointer: true,\n    emptyInsertThreshold: 5,\n  };\n\n  private readonly state: SortableState;\n  private readonly instanceId: symbol;\n  private readonly cleanupManager: CleanupManager;\n  private animationManager: AnimationStateManager;\n  private dragStartTimer?: number;\n  private normalizedGroup: ISortableGroup | null = null;\n\n  public options: ISortableOptions;\n  public el: HTMLElement;\n\n  constructor(el: HTMLElement, options?: Partial<ISortableOptions>) {\n    if (!el || !el.nodeType || el.nodeType !== 1) {\n      throw new Error('Sortable: `el` must be HTMLElement, not null or undefined');\n    }\n\n    this.instanceId = Symbol('SortableInstance');\n    this.cleanupManager = CleanupManager.getInstance();\n    this.el = el;\n    this.options = { ...Sortable.defaultOptions, ...options };\n    this.state = SortableState.getInstance();\n\n    // Initialize animation manager with cleanup\n    this.animationManager = new AnimationStateManager(this);\n    this.cleanupManager.registerAnimationCleanup(this.instanceId, () => {\n      this.animationManager.destroy();\n    });\n\n    // Register this instance in state\n    this.state.registerInstance(el, this);\n\n    // Initialize event listeners\n    this.initializeEventListeners();\n\n    // Prepare group options if specified\n    if (this.options.group) {\n      this.prepareGroup();\n    }\n  }\n\n  private initializeEventListeners(): void {\n    const verifyDragHandler: ISortableDOMEventListener = (evt: ISortableDOMEvents): void => {\n      this.verifyDrag(evt);\n    };\n\n    // Register main event listeners\n    if (this.options.supportPointer) {\n      this.cleanupManager.registerEventListener(this.instanceId, this.el, 'pointerdown', verifyDragHandler);\n    } else {\n      this.cleanupManager.registerEventListener(this.instanceId, this.el, 'mousedown', verifyDragHandler);\n      this.cleanupManager.registerEventListener(this.instanceId, this.el, 'touchstart', verifyDragHandler);\n    }\n\n    // Register scroll listeners if needed\n    const scrollEl = getScrollParent(this.el);\n    if (scrollEl && scrollEl !== document.documentElement && scrollEl !== document.scrollingElement) {\n      const scrollHandler: ISortableDOMEventListener = (evt: ISortableDOMEvents): void => {\n        this.onScroll(evt);\n      };\n\n      this.cleanupManager.registerEventListener(this.instanceId, scrollEl, 'scroll', scrollHandler);\n    }\n  }\n\n  // Helper method that calculates if elements should be swapped based on movement\n  private onMove = (dragRect: DOMRect, targetRect: DOMRect, direction: SortableDirection, sibling: HTMLElement | null): boolean => {\n    const options = this.options;\n    const threshold = options.swapThreshold || 1;\n    const invertSwap = options.invertSwap || false;\n    const invertedThreshold = options.invertedSwapThreshold || threshold;\n\n    const after = invertSwap ? !invertedThreshold : threshold > 0.5;\n    const dragState = this.state.getDragOperation();\n\n    if (direction === 'vertical') {\n      const dragCenter = dragRect.top + dragRect.height / 2;\n      const targetCenter = targetRect.top + targetRect.height / 2;\n      const isOverThreshold = after ? (dragCenter - targetCenter) / targetRect.height > threshold : (targetCenter - dragCenter) / targetRect.height > invertedThreshold;\n\n      if (isOverThreshold) {\n        return this.dispatchMoveEvent(sibling, dragState.sourceEl, after);\n      }\n    } else {\n      const dragCenter = dragRect.left + dragRect.width / 2;\n      const targetCenter = targetRect.left + targetRect.width / 2;\n      const isOverThreshold = after ? (dragCenter - targetCenter) / targetRect.width > threshold : (targetCenter - dragCenter) / targetRect.width > invertedThreshold;\n\n      if (isOverThreshold) {\n        return this.dispatchMoveEvent(sibling, dragState.sourceEl, after);\n      }\n    }\n\n    return false;\n  };\n\n  private dispatchMoveEvent(target: HTMLElement | null, related: HTMLElement | null, willInsertAfter: boolean): boolean {\n    if (!target || !related) return false;\n\n    const moveEvent = new CustomEvent('sortable:move', {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        target,\n        related,\n        willInsertAfter,\n      },\n    });\n\n    this.el.dispatchEvent(moveEvent);\n    return !moveEvent.defaultPrevented;\n  }\n\n  // initial event handler: triggers when a user first interacts with a sortable element\n  private verifyDrag = (evt: ISortableDOMEvents): void => {\n    if (!evt.cancelable) return;\n\n    const target = this.state.getEventTarget(evt);\n    if (!target) return;\n\n    const validTarget = closest(target, this.getDraggableSelector(), this.el, false);\n    if (!validTarget) return;\n\n    // Get initial position from event\n    const coordinates = getEventCoordinates(evt);\n    if (!coordinates) return;\n\n    const { clientX, clientY } = coordinates;\n\n    // Start drag operation in state with initial position\n    this.state.startDrag(validTarget, clientX, clientY);\n\n    // Initialize drag position\n    const touch = getTouchFromEvent(evt);\n    if (touch) {\n      this.state.updateDragPosition(touch.clientX, touch.clientY);\n    }\n\n    this.initializeDragOperation(touch, validTarget);\n  };\n\n  private initDrag = () => {\n    const dragState = this.state.getDragOperation();\n    if (!dragState.sourceEl) return;\n\n    // Create preview\n    this.appendDraggingEl();\n\n    // Setup document listeners\n    const ownerDocument = this.el.ownerDocument;\n    if (this.options.supportPointer) {\n      this.cleanupManager.registerEventListener(this.instanceId, ownerDocument, 'pointermove', this.calculateDrag as EventListener);\n    } else {\n      this.cleanupManager.registerEventListener(this.instanceId, ownerDocument, 'mousemove', this.calculateDrag as EventListener);\n      this.cleanupManager.registerEventListener(this.instanceId, ownerDocument, 'touchmove', this.calculateDrag as EventListener);\n    }\n    this.cleanupManager.registerEventListener(this.instanceId, ownerDocument, 'dragover', this.onDragOver as EventListener);\n\n    // Update state and dispatch\n    this.state.updateDragElements({\n      dragEl: dragState.sourceEl,\n      oldIndex: Array.from(this.el.children).indexOf(dragState.sourceEl),\n    });\n    this.dispatchSortEvent('dragstart');\n  };\n\n  private initializeDragOperation(touch: Touch | PointerEvent | null, target: HTMLElement): void {\n    target.style.willChange = 'transform';\n    this.bindDragListeners(!!touch);\n\n    // Handle delay if needed\n    const delay = (this.options as ISortableOptions).delay;\n\n    if (this.shouldApplyDelay()) {\n      this.dragStartTimer = window.setTimeout(() => {\n        this.initDrag();\n        this.dragStartTimer = undefined;\n      }, delay);\n\n      // Register timer cleanup\n      this.cleanupManager.registerTimer(this.instanceId, this.dragStartTimer);\n    } else {\n      this.initDrag();\n    }\n  }\n\n  // Swap calculation logic: Tracks the dragging element\n  private calculateDrag = (evt: ISortableDOMEvents): void => {\n    const dragState = this.state.getDragOperation();\n    if (!dragState.active || !evt.cancelable) return;\n\n    const coordinates = getEventCoordinates(evt);\n    if (!coordinates) return;\n\n    const { clientX, clientY } = coordinates;\n\n    // Update position in state\n    this.state.updateDragPosition(clientX, clientY);\n\n    if (dragState.dragEl) {\n      evt.preventDefault();\n      this.emulateDragOver(evt);\n\n      // Update preview position\n      const mtx = matrix(dragState.dragEl) || { e: 0, f: 0 };\n      const dx = clientX - dragState.position.clientX;\n      const dy = clientY - dragState.position.clientY;\n\n      dragState.dragEl.style.transform = `translate3d(${dx + (mtx.e || 0)}px,${dy + (mtx.f || 0)}px,0)`;\n    } else if (!dragState.moved) {\n      const threshold = (this.options as ISortableOptions).touchStartThreshold || 1;\n      const moveDistance = Math.max(Math.abs(clientX - dragState.position.clientX), Math.abs(clientY - dragState.position.clientY));\n\n      if (moveDistance >= threshold) {\n        this.state.updateDragElements({ moved: true });\n        this.initDrag();\n      }\n    }\n  };\n\n  private onDragOver = (evt: ISortableDOMEvents): void => {\n    const dragState = this.state.getDragOperation();\n    if (!dragState.active || !dragState.sourceEl) return;\n\n    evt.preventDefault();\n    evt.stopPropagation();\n\n    let clientX: number;\n    let clientY: number;\n\n    // Extract coordinates based on event type\n    if (this.isTouchEvent(evt)) {\n      const touch = evt.touches[0];\n      if (!touch) return;\n      clientX = touch.clientX;\n      clientY = touch.clientY;\n    } else if (this.isDragEvent(evt)) {\n      clientX = evt.clientX;\n      clientY = evt.clientY;\n    } else {\n      // MouseEvent\n      clientX = evt.clientX;\n      clientY = evt.clientY;\n    }\n\n    const targetEl = document.elementFromPoint(clientX, clientY) as HTMLElement | null;\n    if (!targetEl) return;\n\n    const validTarget = closest(targetEl, this.getDraggableSelector(), this.el, false);\n    if (!validTarget || validTarget === dragState.sourceEl) return;\n\n    const rect = getRect(validTarget);\n    const direction = this.getDirection(evt, validTarget);\n\n    // Calculate previous and next siblings for potential swapping\n    const prevSibling = validTarget.previousElementSibling as HTMLElement | null;\n    const nextSibling = validTarget.nextElementSibling as HTMLElement | null;\n\n    // Calculate insertion point based on direction and position\n    const centerY = rect.top + rect.height / 2;\n    const centerX = rect.left + rect.width / 2;\n    const isVertical = direction === 'vertical';\n    const coordinate = isVertical ? clientY : clientX;\n    const center = isVertical ? centerY : centerX;\n\n    // Determine if we should insert before or after the target\n    const insertBefore = coordinate < center;\n    const sibling = insertBefore ? prevSibling : nextSibling;\n\n    // Get drag element rect for comparison\n    const dragRect = getRect(dragState.sourceEl);\n\n    // Check if we should move the element\n    if (this.onMove(dragRect, rect, direction, sibling)) {\n      // Capture the current state for animation\n      this.captureAnimationState();\n\n      // Insert the dragged element\n      if (insertBefore) {\n        validTarget.parentNode?.insertBefore(dragState.sourceEl, validTarget);\n      } else {\n        validTarget.parentNode?.insertBefore(dragState.sourceEl, validTarget.nextSibling);\n      }\n\n      // Add animation state for the moved target\n      this.addAnimationState({\n        target: validTarget,\n        rect: getRect(validTarget),\n      });\n\n      // Update drag state with new position\n      this.state.updateDragPosition(clientX, clientY);\n\n      // Dispatch sort event if needed\n      const oldIndex = dragState.oldIndex ?? -1;\n      const newIndex = Array.from(this.el.children).indexOf(dragState.sourceEl);\n\n      if (oldIndex !== newIndex) {\n        this.dispatchSortEvent('sort', {\n          oldIndex,\n          newIndex,\n          dragEl: dragState.sourceEl,\n          target: validTarget,\n        });\n      }\n\n      // Animate elements if animation duration is set\n      if ((this.options as ISortableOptions).animation) {\n        this.animateAll();\n      }\n    }\n  };\n\n  private onScroll = (evt: ISortableDOMEvents): void => {\n    const dragState = this.state.getDragOperation();\n    if (!dragState.active || !dragState.dragEl) return;\n\n    // Get scroll coordinates\n    const { scrollTop, scrollLeft } = evt.target as HTMLElement;\n\n    // Update drag element position based on scroll\n    const mtx = matrix(dragState.dragEl) || { e: 0, f: 0 };\n    const dx = dragState.position.clientX - dragState.position.initialX;\n    const dy = dragState.position.clientY - dragState.position.initialY;\n\n    dragState.dragEl.style.transform = `translate3d(${dx + (mtx.e || 0)}px,${dy + (mtx.f || 0)}px,0)`;\n\n    // Update scroll position in state\n    this.state.updateScrollPosition(scrollTop, scrollLeft);\n  };\n\n  private emulateDragOver = (evt: ISortableDOMEvents): void => {\n    // 1. Validate drag state\n    const dragState = this.state.getDragOperation();\n    if (!dragState.active || !dragState.dragEl) return;\n\n    // 2. Get coordinates from event\n    const coordinates = getEventCoordinates(evt);\n    if (!coordinates) return;\n\n    const { clientX, clientY } = coordinates;\n\n    // 3. Handle drag preview visibility\n    this.toggleDraggingElVisibility(false);\n\n    // 4. Find target element at point\n    const targetAtPoint = document.elementFromPoint(clientX, clientY);\n    if (!targetAtPoint || !(targetAtPoint instanceof HTMLElement)) {\n      this.toggleDraggingElVisibility(true);\n      return;\n    }\n\n    // 5. Show drag preview\n    this.toggleDraggingElVisibility(true);\n\n    // 6. Handle dragging outside current sortable\n    if (this.isOutsideThisEl(targetAtPoint)) {\n      const targetSortable = this.getSortableParent(targetAtPoint);\n      if (targetSortable && targetSortable !== this) {\n        targetSortable.handleDragOver(evt);\n        return;\n      }\n    }\n\n    // 7. Get valid drag target\n    const validTarget = closest(targetAtPoint, this.getDraggableSelector(), this.el, false);\n    if (!validTarget || validTarget === dragState.sourceEl) return;\n\n    // 8. Calculate rects and direction\n    const dragRect = getRect(dragState.dragEl);\n    const targetRect = getRect(validTarget);\n    const direction = this.getDirection(evt, validTarget);\n\n    // 9. Determine sibling based on direction\n    const sibling = this.getTargetSibling(validTarget, direction);\n\n    // 10. Check if move is valid and perform animation\n    if (this.onMove(dragRect, targetRect, direction, sibling)) {\n      this.captureAnimationState();\n      this._animate(validTarget);\n      this.addAnimationState({\n        target: validTarget,\n        rect: getRect(validTarget),\n      });\n    }\n  };\n\n  private onDrop = (evt: Event): void => {\n    if (evt) {\n      evt.preventDefault();\n    }\n\n    const dragState = this.state.getDragOperation();\n    if (!dragState.active || !dragState.dragEl) return;\n\n    // Remove preview\n    if (dragState.dragEl.parentNode) {\n      dragState.dragEl.parentNode.removeChild(dragState.dragEl);\n    }\n\n    // Reset styles\n    const draggingClass = (this.options as ISortableOptions).draggingClass || 'sortable-dragging';\n    const fallbackClass = (this.options as ISortableOptions).fallbackClass || 'sortable-fallback';\n\n    if (dragState.sourceEl) {\n      toggleClass(dragState.sourceEl, draggingClass, false);\n      toggleClass(dragState.sourceEl, fallbackClass, false);\n    }\n\n    // Dispatch drop event\n    this.dispatchSortEvent('drop');\n\n    // Reset state\n    this.state.endDrag();\n  };\n\n  // Helper method to determine target sibling\n  private getTargetSibling(target: HTMLElement, direction: SortableDirection): HTMLElement | null {\n    return direction === 'vertical' ? (target.nextElementSibling as HTMLElement | null) : (target.previousElementSibling as HTMLElement | null);\n  }\n\n  private getSortableParent = (el: HTMLElement): ISortable | null => {\n    let current: HTMLElement | null = el;\n\n    while (current && current !== document.body) {\n      const instance = this.state.getInstance(current);\n      if (instance) return instance;\n      current = current.parentElement;\n    }\n\n    return null;\n  };\n\n  private toggleDraggingElVisibility(show: boolean): void {\n    const dragState = this.state.getDragOperation();\n    if (dragState.dragEl) {\n      css(dragState.dragEl, 'display', show ? '' : 'none');\n    }\n  }\n\n  private appendDraggingEl(): void {\n    const dragState: Readonly<DragState> = this.state.getDragOperation();\n    if (!dragState.sourceEl) return;\n\n    // Early container resolution\n    const container: HTMLElement = (this.options as ISortableOptions).fallbackOnBody ? document.body : this.el;\n    const scrollParent: HTMLElement | null = getScrollParent(this.el);\n    const isAbsolutePositioning: boolean = (scrollParent && scrollParent !== document.body) ?? false;\n\n    // Get initial rect with proper parameters\n    const rect: DOMRect = getRect(dragState.sourceEl, true, (this.options as ISortableOptions).fallbackOnBody, true, container);\n\n    // Create drag element with all properties\n    const dragEl: HTMLElement = this.createDragElement(dragState.sourceEl, rect);\n\n    // Position the element\n    this.positionDragElement(dragEl, rect, isAbsolutePositioning, scrollParent);\n\n    // Append and update state\n    container.appendChild(dragEl);\n    this.state.updateDragElements({ dragEl });\n  }\n\n  private createDragElement(sourceEl: HTMLElement, rect: DOMRect): HTMLElement {\n    const dragEl: HTMLElement = sourceEl.cloneNode(true) as HTMLElement;\n    const { draggingClass = 'sortable-dragging', fallbackClass = 'sortable-fallback' } = this.options;\n\n    // Add classes\n    toggleClass(dragEl, fallbackClass, true);\n    toggleClass(dragEl, draggingClass, true);\n\n    // Apply base styles\n    const baseStyles: Record<string, string> = {\n      position: 'fixed',\n      zIndex: '100000',\n      pointerEvents: 'none',\n      width: `${rect.width}px`,\n      height: `${rect.height}px`,\n      boxSizing: 'border-box',\n      margin: '0',\n      opacity: '0.8',\n      transition: '',\n      transform: '',\n    };\n\n    css(dragEl, baseStyles);\n    return dragEl;\n  }\n\n  private positionDragElement(dragEl: HTMLElement, rect: DOMRect, isAbsolutePositioning: boolean, scrollParent: HTMLElement | null): void {\n    if (!isAbsolutePositioning) {\n      css(dragEl, {\n        top: `${rect.top}px`,\n        left: `${rect.left}px`,\n      });\n      return;\n    }\n\n    // Handle scroll parent positioning\n    const scrollParentRect: DOMRect = getRect(scrollParent!);\n    const scroll: { scrollTop: number; scrollLeft: number } = getScroll(scrollParent!);\n\n    css(dragEl, {\n      position: 'absolute',\n      top: `${rect.top - scrollParentRect.top + scroll.scrollTop}px`,\n      left: `${rect.left - scrollParentRect.left + scroll.scrollLeft}px`,\n    });\n  }\n\n  // Type guards for event types\n  private isTouchEvent(evt: Event): evt is TouchEvent {\n    return 'touches' in evt;\n  }\n\n  private isDragEvent(evt: Event): evt is DragEvent {\n    return 'dataTransfer' in evt;\n  }\n\n  private shouldApplyDelay(): boolean {\n    return !!(this.options.delay && this.options.delay > 0);\n  }\n\n  private bindDragListeners(isTouch: boolean): void {\n    const doc = this.el.ownerDocument;\n\n    if ((this.options as ISortableOptions).supportPointer) {\n      this.cleanupManager.registerEventListener(this.instanceId, doc, 'pointermove', this.calculateDrag as EventListener);\n      this.cleanupManager.registerEventListener(this.instanceId, doc, 'pointerup', this.onDrop as EventListener);\n      this.cleanupManager.registerEventListener(this.instanceId, doc, 'pointercancel', this.onDrop as EventListener);\n    } else {\n      this.cleanupManager.registerEventListener(this.instanceId, doc, isTouch ? 'touchmove' : 'mousemove', this.calculateDrag as EventListener);\n      this.cleanupManager.registerEventListener(this.instanceId, doc, isTouch ? 'touchend' : 'mouseup', this.onDrop as EventListener);\n      if (isTouch) {\n        this.cleanupManager.registerEventListener(this.instanceId, doc, 'touchcancel', this.onDrop as EventListener);\n      }\n    }\n  }\n\n  private _animate(target: HTMLElement): void {\n    const dragState = this.state.getDragOperation();\n    if (!dragState.sourceEl) return;\n\n    const oldIndex = Array.from(this.el.children).indexOf(dragState.sourceEl);\n    const newIndex = Array.from(this.el.children).indexOf(target);\n\n    if (oldIndex !== newIndex) {\n      this.el.insertBefore(dragState.sourceEl, target);\n      this.dispatchSortEvent('sort', {\n        oldIndex,\n        newIndex,\n        dragEl: dragState.sourceEl,\n        target,\n      });\n    }\n  }\n\n  private dispatchSortEvent(name: string, detail: Record<string, any> = {}): void {\n    const evt = new CustomEvent(name, {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        ...detail,\n        from: this.el,\n      },\n    });\n\n    this.el.dispatchEvent(evt);\n  }\n\n  private getDirection(evt: Event, target: HTMLElement): SortableDirection {\n    const direction = this.options.direction;\n    if (typeof direction === 'function') {\n      return direction.call(this, evt, target, this.state.getDragOperation().sourceEl);\n    }\n    return direction || 'vertical';\n  }\n\n  private isOutsideThisEl(target: HTMLElement | null): boolean {\n    return !target || (!this.el.contains(target) && target !== this.el);\n  }\n\n  public destroy(): void {\n    this.state.destroyInstance(this.instanceId);\n  }\n\n  public option<K extends keyof ISortableOptions>(name: K, value?: ISortableOptions[K]): ISortableOptions[K] {\n    if (value === undefined) {\n      return this.options[name];\n    }\n\n    this.options[name] = value;\n    if (name === 'group') {\n      this.prepareGroup();\n    }\n    return value;\n  }\n\n  public toArray(): string[] {\n    return getElementsArray(this.el, this.getDraggableSelector(), (this.options as ISortableOptions).dataIdAttr || 'data-id');\n  }\n\n  public sort(order: string[], useAnimation?: boolean): void {\n    const items: { [key: string]: HTMLElement } = {};\n    const rootEl = this.el;\n\n    this.toArray().forEach((id, i) => {\n      const el = rootEl.children[i] as HTMLElement;\n      if (closest(el, this.getDraggableSelector(), rootEl, false)) {\n        items[id] = el;\n      }\n    });\n\n    useAnimation && this.captureAnimationState();\n\n    order.forEach((id) => {\n      if (items[id]) {\n        rootEl.removeChild(items[id]);\n        rootEl.appendChild(items[id]);\n      }\n    });\n\n    useAnimation && this.animateAll();\n  }\n\n  // unused so far\n  public save(): void {\n    const store = (this.options as ISortableOptions).store;\n    store?.set?.(this);\n  }\n\n  // Animation Methods\n  public captureAnimationState(): void {\n    this.animationManager.captureAnimationState();\n  }\n\n  public addAnimationState(state: IAnimationState): void {\n    this.animationManager.addAnimationState(state);\n  }\n\n  public removeAnimationState(target: HTMLElement): void {\n    this.animationManager.removeAnimationState(target);\n  }\n\n  public animateAll(callback?: () => void): void {\n    this.animationManager.animateAll(callback);\n  }\n\n  public animate(target: HTMLElement, currentRect: DOMRect, toRect: DOMRect, duration: number): void {\n    this.animationManager.animate(target, currentRect, toRect, duration);\n  }\n\n  public handleDragOver(evt: ISortableDOMEvents): void {\n    this.onDragOver(evt);\n  }\n\n  private getDraggableSelector(): string {\n    return (this.options as ISortableOptions).draggable;\n  }\n\n  private prepareGroup(): void {\n    const options = this.options;\n\n    if (!options.group) {\n      options.group = {\n        name: undefined,\n        pull: true,\n        put: true,\n        revertClone: false,\n      };\n    }\n\n    if (typeof options.group === 'string') {\n      options.group = { name: options.group };\n    }\n\n    const group = options.group as {\n      name?: string;\n      pull?: boolean | 'clone' | ((to: ISortable, from: ISortable, dragEl: HTMLElement, event: Event) => boolean);\n      put?: boolean | string[] | ((to: ISortable, from: ISortable, dragEl: HTMLElement, event: Event) => boolean);\n      revertClone?: boolean;\n    };\n\n    this.normalizedGroup = {\n      name: group.name ?? null,\n      checkPull: (to: ISortable, from: ISortable, dragEl: HTMLElement, evt: Event): boolean | 'clone' => {\n        if (!group.pull) return false;\n        if (typeof group.pull === 'function') {\n          return group.pull(to, from, dragEl, evt);\n        }\n        return group.pull;\n      },\n      checkPut: (to: ISortable, from: ISortable, dragEl: HTMLElement, evt: Event): boolean => {\n        if (!group.put) return false;\n        if (Array.isArray(group.put)) {\n          const fromGroup = (from as Sortable).normalizedGroup;\n          return group.put.includes(fromGroup?.name ?? '');\n        }\n        if (typeof group.put === 'function') {\n          return group.put(to, from, dragEl, evt);\n        }\n        return !!group.put;\n      },\n      revertClone: group.revertClone ?? false,\n    };\n\n    // Register group cleanup\n    this.cleanupManager.registerCustomCleanup(this.instanceId, () => {\n      this.normalizedGroup = null;\n    });\n  }\n}\n"],"names":["getTouchFromEvent","evt","isTouchEvent","touches","isPointerEvent","pointerType","getEventCoordinates","touch","clientX","clientY","captureMode","capture","passive","CleanupManager","tasks","Map","static","constructor","getInstance","instance","removeEventListener","el","event","fn","registerEventListener","instanceId","element","handler","addEventListener","this","addTask","type","cleanup","registerTimer","timerId","clearTimeout","registerAnimationCleanup","registerCustomCleanup","task","has","set","Set","get","add","forEach","delete","cleanupAll","_tasks","clear","SORTABLE_INSTANCE_KEY","Symbol","SortableState","state","listeners","cleanupManager","activeSortable","instances","dragOperation","active","sourceEl","dragEl","ghostEl","cloneEl","parentEl","nextEl","lastDownEl","oldIndex","newIndex","oldDraggableIndex","newDraggableIndex","moved","position","initialX","initialY","dx","dy","registerInstance","Error","notifyListeners","destroyInstance","elementToRemove","removeInstance","subscribe","listener","getState","Object","freeze","startDrag","sortable","getElementIndex","updateDragPosition","oldPos","updateDragElements","elements","endDrag","updateScrollPosition","scrollTop","scrollLeft","getElementFromPoint","x","y","prevDisplay","style","display","document","elementFromPoint","getEventTarget","target","HTMLElement","shadowRoot","shadowTarget","Array","from","parentElement","children","indexOf","getActiveSortable","getDragOperation","hasInstance","getInstanceCount","size","reset","_","matches","selector","substring","getParentOrHost","host","nodeType","parentNode","closest","ctx","includeCTX","current","toggleClass","name","classList","css","prop","val","undefined","getComputedStyle","startsWith","entries","key","value","matrix","selfOnly","transforms","transform","MatrixConstructor","window","DOMMatrix","WebKitCSSMatrix","CSSMatrix","MSCSSMatrix","getRect","relativeToContainingBlock","relativeToNonStaticParent","undoScale","container","top","left","bottom","innerHeight","right","innerWidth","width","height","toJSON","elRect","getBoundingClientRect","containerRect","borderTop","parseInt","borderLeft","elMatrix","a","scaleX","d","scaleY","isRectEqual","rect1","rect2","Math","round","animate","currentRect","toRect","duration","options","translateX","translateY","animatingX","animatingY","offsetWidth","forceRepaint","easing","animated","setTimeout","AnimationStateManager","animationStates","animationCallbackId","captureAnimationState","animation","dragState","child","rect","push","fromRect","thisAnimationDuration","compensateForAnimation","addAnimationState","removeAnimationState","index","arr","obj","i","length","keys","every","indexOfObject","splice","animateAll","callback","clearAnimation","animating","maxDuration","processAnimationStates","scheduleCallback","animateElement","computedMatrix","DOMRect","m41","m42","calculateAnimationDuration","max","setupAnimationReset","prevFromRect","prevToRect","animatingRect","dx1","pow","dy1","dx2","dy2","sqrt","calculateRealTime","updateAnimationTracking","animationResetTimer","animationTime","destroy","generateElementId","str","tagName","className","src","href","textContent","join","hash","charCodeAt","abs","toString","getScrollParent","includeHidden","parent","overflow","overflowY","overflowX","test","includes","scrollingElement","documentElement","Sortable","group","sort","disabled","store","handle","draggable","swapThreshold","invertSwap","invertedSwapThreshold","removeCloneOnHide","direction","draggingClass","chosenClass","dragClass","ignore","filter","preventOnFilter","setData","dataTransfer","activeEl","dropBubble","dragoverBubble","dataIdAttr","delay","touchStartThreshold","forceFallback","fallbackClass","fallbackOnBody","fallbackTolerance","fallbackOffset","supportPointer","emptyInsertThreshold","animationManager","dragStartTimer","normalizedGroup","defaultOptions","initializeEventListeners","prepareGroup","verifyDragHandler","verifyDrag","scrollEl","scrollHandler","onScroll","onMove","dragRect","targetRect","sibling","threshold","invertedThreshold","after","dragCenter","targetCenter","dispatchMoveEvent","related","willInsertAfter","moveEvent","CustomEvent","bubbles","cancelable","detail","dispatchEvent","defaultPrevented","validTarget","getDraggableSelector","coordinates","initializeDragOperation","initDrag","appendDraggingEl","ownerDocument","calculateDrag","onDragOver","dispatchSortEvent","willChange","bindDragListeners","shouldApplyDelay","preventDefault","emulateDragOver","mtx","e","f","stopPropagation","isDragEvent","targetEl","getDirection","prevSibling","previousElementSibling","nextSibling","nextElementSibling","centerY","centerX","isVertical","insertBefore","toggleDraggingElVisibility","targetAtPoint","isOutsideThisEl","targetSortable","getSortableParent","handleDragOver","getTargetSibling","_animate","onDrop","removeChild","body","show","scrollParent","isAbsolutePositioning","createDragElement","positionDragElement","appendChild","cloneNode","baseStyles","zIndex","pointerEvents","boxSizing","margin","opacity","transition","scrollParentRect","scroll","pageYOffset","pageXOffset","isTouch","doc","call","contains","option","toArray","draggableSelector","order","getAttribute","getElementsArray","useAnimation","items","rootEl","id","save","pull","put","revertClone","checkPull","to","checkPut","isArray","fromGroup"],"mappings":"AAmBM,SAAUA,EAAkBC,GAChC,OAdI,SAAuBA,GAC3B,MAAO,YAAaA,CACtB,CAYMC,CAAaD,IAAQA,EAAIE,QAAQ,GAC5BF,EAAIE,QAAQ,GAXjB,SAAyBF,GAC7B,MAAO,gBAAiBA,CAC1B,CAUaG,CAAeH,IAA4B,UAApBA,EAAII,YAC7BJ,EAEF,IACT,CAOM,SAAUK,EAAoBL,GAClC,MAAMM,EAAQP,EAAkBC,GAChC,OAAIM,EACK,CACLC,QAASD,EAAMC,QACfC,QAASF,EAAME,SAKf,YAAaR,EACR,CACLO,QAASP,EAAIO,QACbC,QAASR,EAAIQ,SAIV,IACT,CC5CA,MAAMC,EAA4B,CAChCC,SAAS,EACTC,SAAS,SAQEC,EACHC,MAAwC,IAAIC,IAC5CC,gBAER,WAAAC,GAAA,CAEO,kBAAOC,GAIZ,OAHKL,EAAeM,WAClBN,EAAeM,SAAW,IAAIN,GAEzBA,EAAeM,SAGhB,mBAAAC,CAAoBC,EAA4BC,EAAeC,GACrEF,EAAGD,oBAAoBE,EAAOC,EAAqBb,GAG9C,qBAAAc,CAAsBC,EAAoBC,EAAiCJ,EAAeK,GAC/FD,EAAQE,iBAAiBN,EAAOK,EAA0BjB,GAC1DmB,KAAKC,QAAQL,EAAY,CACvBM,KAAM,QACNC,QAAS,IAAMH,KAAKT,oBAAoBM,EAASJ,EAAOK,KAIrD,aAAAM,CAAcR,EAAoBS,GACvCL,KAAKC,QAAQL,EAAY,CACvBM,KAAM,QACNC,QAAS,IAAMG,aAAaD,KAIzB,wBAAAE,CAAyBX,EAAoBO,GAClDH,KAAKC,QAAQL,EAAY,CACvBM,KAAM,YACNC,YAIG,qBAAAK,CAAsBZ,EAAoBO,GAC/CH,KAAKC,QAAQL,EAAY,CACvBM,KAAM,SACNC,YAII,OAAAF,CAAQL,EAAoBa,GAC7BT,KAAKf,MAAMyB,IAAId,IAClBI,KAAKf,MAAM0B,IAAIf,EAAY,IAAIgB,KAEjCZ,KAAKf,MAAM4B,IAAIjB,GAAakB,IAAIL,GAG3B,OAAAN,CAAQP,GACb,MAAMX,EAAQe,KAAKf,MAAM4B,IAAIjB,GACxBX,IAGLA,EAAM8B,SAASN,GAASA,EAAKN,YAG7BH,KAAKf,MAAM+B,OAAOpB,IAGb,UAAAqB,GACLjB,KAAKf,MAAM8B,SAAQ,CAACG,EAA2BtB,KAC7CI,KAAKG,QAAQP,EAAW,IAE1BI,KAAKf,MAAMkC,SC/ER,MAAMC,EAAwBC,OAAO,0BAsC/BC,EACHnC,gBACAoC,MACAC,UAAsC,IAAIZ,IAC1Ca,eAER,WAAArC,GACEY,KAAKuB,MAAQ,CACXG,eAAgB,KAChBC,UAAW,IAAIzC,IACf0C,cAAe,CACbC,QAAQ,EACRC,SAAU,KACVC,OAAQ,KACRC,QAAS,KACTC,QAAS,KACTC,SAAU,KACVC,OAAQ,KACRC,WAAY,KACZC,SAAU,KACVC,SAAU,KACVC,kBAAmB,KACnBC,kBAAmB,KACnBC,OAAO,EACPC,SAAU,CACR/D,QAAS,EACTC,QAAS,EACT+D,SAAU,EACVC,SAAU,EACVC,GAAI,EACJC,GAAI,KAIV9C,KAAKyB,eAAiBzC,EAAeK,cAGhC,kBAAOA,GAIZ,OAHKiC,EAAchC,WACjBgC,EAAchC,SAAW,IAAIgC,GAExBA,EAAchC,SAIhB,gBAAAyD,CAAiBvD,EAAiBF,GACvC,GAAIU,KAAKuB,MAAMI,UAAUjB,IAAIlB,GAC3B,MAAM,IAAIwD,MAAM,2CAElBhD,KAAKuB,MAAMI,UAAUhB,IAAInB,EAAIF,GAC5BE,EAAuB4B,GAAyB9B,EACjDU,KAAKiD,kBAGA,eAAAC,CAAgBtD,GAErBI,KAAKyB,eAAetB,QAAQP,GAG5B,IAAIuD,EAAsC,KAC1CnD,KAAKuB,MAAMI,UAAUZ,SAAQ,CAACzB,EAAUE,KACjCF,EAAiBM,aAAeA,IACnCuD,EAAkB3D,MAIlB2D,GACFnD,KAAKoD,eAAeD,GAIjB,cAAAC,CAAe5D,GACpBQ,KAAKuB,MAAMI,UAAUX,OAAOxB,UACpBA,EAAuB4B,GAC/BpB,KAAKiD,kBAGA,WAAA5D,CAAYG,GAEjB,MAAMF,EAAWU,KAAKuB,MAAMI,UAAUd,IAAIrB,GAC1C,OAAIF,GAGIE,EAAuB4B,GAI1B,SAAAiC,CAAUC,GAEf,OADAtD,KAAKwB,UAAUV,IAAIwC,GACZ,IAAMtD,KAAKwB,UAAUR,OAAOsC,GAG7B,eAAAL,GACN,MAAM1B,EAAQvB,KAAKuD,WACnBvD,KAAKwB,UAAUT,SAASuC,GAAaA,EAAS/B,KAIzC,QAAAgC,GACL,OAAOC,OAAOC,OAAO,IAAKzD,KAAKuB,QAI1B,SAAAmC,CAAU5B,EAAuBnD,EAAkB,EAAGC,EAAkB,GAC7E,GAAIoB,KAAKuB,MAAMK,cAAcC,OAC3B,MAAM,IAAImB,MAAM,sCAGlB,MAAMW,EAAW3D,KAAKX,YAAYyC,GAClC,IAAK6B,EACH,MAAM,IAAIX,MAAM,0CAGlBhD,KAAKuB,MAAMG,eAAiBiC,EAC5B3D,KAAKuB,MAAMK,cAAgB,IACtB5B,KAAKuB,MAAMK,cACdC,QAAQ,EACRC,WACAO,SAAUrC,KAAK4D,gBAAgB9B,GAC/BY,SAAU,CACR/D,UACAC,UACA+D,SAAUhE,EACViE,SAAUhE,EACViE,GAAI,EACJC,GAAI,IAGR9C,KAAKiD,kBAGA,kBAAAY,CAAmBlF,EAAiBC,GACzC,MAAMkF,EAAS9D,KAAKuB,MAAMK,cAAcc,SACxC1C,KAAKuB,MAAMK,cAAcc,SAAW,CAClC/D,UACAC,UACA+D,SAAUmB,EAAOnB,SACjBC,SAAUkB,EAAOlB,SACjBC,GAAIlE,EAAUmF,EAAOnF,QACrBmE,GAAIlE,EAAUkF,EAAOlF,SAEvBoB,KAAKiD,kBAGA,kBAAAc,CAAmBC,GACxBhE,KAAKuB,MAAMK,cAAgB,IACtB5B,KAAKuB,MAAMK,iBACXoC,GAELhE,KAAKiD,kBAGA,OAAAgB,GACLjE,KAAKuB,MAAMG,eAAiB,KAC5B1B,KAAKuB,MAAMK,cAAgB,IACtB5B,KAAKuB,MAAMK,cACdC,QAAQ,EACRC,SAAU,KACVC,OAAQ,KACRC,QAAS,KACTC,QAAS,KACTI,SAAU,KACVC,SAAU,MAEZtC,KAAKiD,kBAGA,oBAAAiB,CAAqBC,EAAmBC,GAE7CpE,KAAKuB,MAAMK,cAAcc,SAAW,IAC/B1C,KAAKuB,MAAMK,cAAcc,SAC5BG,GAAI7C,KAAKuB,MAAMK,cAAcc,SAASG,GAAKuB,EAC3CtB,GAAI9C,KAAKuB,MAAMK,cAAcc,SAASI,GAAKqB,GAE7CnE,KAAKiD,kBAIA,mBAAAoB,CAAoBC,EAAWC,GACpC,MAAMxC,EAAS/B,KAAKuB,MAAMK,cAAcG,OACxC,GAAIA,EAAQ,CACV,MAAMyC,EAAczC,EAAO0C,MAAMC,QACjC3C,EAAO0C,MAAMC,QAAU,OACvB,MAAM7E,EAAU8E,SAASC,iBAAiBN,EAAGC,GAE7C,OADAxC,EAAO0C,MAAMC,QAAUF,EAChB3E,EAET,OAAO8E,SAASC,iBAAiBN,EAAGC,GAI/B,cAAAM,CAAezG,GACpB,MAAM0G,OAAEA,GAAW1G,EACnB,KAAM0G,aAAkBC,aAAc,OAAO,KAE7C,GAAID,EAAOE,WAAY,CACrB,MAAMtG,EAAQP,EAAkBC,GAChC,GAAIM,EAAO,CACT,MAAMuG,EAAeH,EAAOE,WAAWJ,iBAAiBlG,EAAMC,QAASD,EAAME,SAC7E,GAAIqG,aAAwBF,YAC1B,OAAOE,GAKb,OAAOH,EAID,eAAAlB,CAAgBpE,GACtB,OAAO0F,MAAMC,KAAK3F,EAAG4F,eAAeC,UAAY,IAAIC,QAAQ9F,GAIvD,iBAAA+F,GACL,OAAOvF,KAAKuB,MAAMG,eAGb,gBAAA8D,GACL,OAAOhC,OAAOC,OAAO,IAAKzD,KAAKuB,MAAMK,gBAIhC,WAAA6D,CAAYjG,GACjB,OAAOQ,KAAKuB,MAAMI,UAAUjB,IAAIlB,IAAO4B,KAAyB5B,EAI3D,gBAAAkG,GACL,OAAO1F,KAAKuB,MAAMI,UAAUgE,KAIvB,KAAAC,GACL5F,KAAKuB,MAAMI,UAAUZ,SAAQ,CAAC8E,EAAGrG,IAAOQ,KAAKoD,eAAe5D,KAC5DQ,KAAKiE,UACLjE,KAAKwB,UAAUL,SCzQZ,MAAM2E,EAAU,CAACtG,EAAwBuG,KAC9C,IAAKA,IAAavG,EAAI,OAAO,EAET,MAAhBuG,EAAS,KACXA,EAAWA,EAASC,UAAU,IAGhC,IACE,OAAOxG,EAAGsG,UAAUC,KAAa,EACjC,MACA,OAAO,IAIEE,EAAmBzG,GAAqBA,EAAW0G,MAAQ1G,IAAOmF,UAAanF,EAAW0G,KAAKC,SAAY3G,EAAW0G,KAAQ1G,EAAG4G,WAEjIC,EAAU,CAAC7G,EAAwBuG,EAAkBO,EAAY3B,SAAU4B,GAAa,KACnG,IAAK/G,EAAI,OAAO,KAEhB,IAAIgH,EAAuBhH,EAC3B,EAAG,CACD,GAAiB,MAAZuG,IAAqC,MAAhBA,EAAS,GAAaS,EAAQJ,aAAeE,GAAOR,EAAQU,EAAwBT,GAAYD,EAAQU,EAAwBT,KAAgBQ,GAAcC,IAAYF,EAClM,OAAOE,EAGT,GAAIA,IAAYF,EAAK,YACbE,EAAUP,EAAgBO,IAEpC,OAAO,IAAI,EAGAC,EAAc,CAACjH,EAAiBkH,EAAcnF,KACpD/B,GAAOkH,GACZlH,EAAGmH,YAAYpF,EAAQ,MAAQ,UAAUmF,EAAK,EAKnCE,EAAM,CAACpH,EAAiBqH,EAA8BC,KACjE,GAAKtH,GAAIiF,MAET,GAAoB,iBAAToC,EAAX,CAUA,QAAYE,IAARD,EACF,OAAOE,iBAAiBxH,GAAIqH,GAGxBA,KAAQrH,EAAGiF,OAAWoC,EAAKI,WAAW,YAC1CJ,EAAO,WAAWA,KAGpBrH,EAAGiF,MAAMoC,GAAe,GAAGC,IAAqB,iBAARA,EAAmB,GAAK,YAjB9DtD,OAAO0D,QAAQL,GAAM9F,SAAQ,EAAEoG,EAAKC,MAC5BD,KAAO3H,EAAGiF,OAAW0C,EAAIF,WAAW,YACxCE,EAAM,WAAWA,KAEnB3H,EAAGiF,MAAM0C,GAAc,GAAGC,IAAyB,iBAAVA,EAAqB,GAAK,MAAM,GAaP,EAG3DC,EAAS,CAAC7H,EAA0B8H,GAAW,KAC1D,IAAIC,EAAa,GAEjB,GAAkB,iBAAP/H,EACT+H,EAAa/H,MACR,CACL,IAAIgH,EAA8BhH,EAClC,EAAG,CACD,MAAMgI,EAAYZ,EAAIJ,EAAS,aAC3BgB,GAA2B,SAAdA,IACfD,EAAa,GAAGC,KAAaD,IAEhC,QAASD,IAAad,EAAUA,EAAQpB,gBAG3C,MAAMqC,EAAoBC,OAAOC,WAAaD,OAAOE,iBAAmBF,OAAOG,WAAaH,OAAOI,YACnG,OAAOL,EAAqB,IAAIA,EAAkBF,GAA0B,IAAI,EAGrEQ,EAAU,CAACvI,EAA0BwI,GAA4B,EAAOC,GAA4B,EAAOC,GAAY,EAAOC,KACzI,GAAI3I,IAAOkI,OACT,MAAO,CACLU,IAAK,EACLC,KAAM,EACNC,OAAQZ,OAAOa,YACfC,MAAOd,OAAOe,WACdC,MAAOhB,OAAOe,WACdE,OAAQjB,OAAOa,YACfjE,EAAG,EACHC,EAAG,EACH,MAAAqE,GACE,MAAO,CACLtE,EAAGtE,KAAKsE,EACRC,EAAGvE,KAAKuE,EACR6D,IAAKpI,KAAKoI,IACVI,MAAOxI,KAAKwI,MACZF,OAAQtI,KAAKsI,OACbD,KAAMrI,KAAKqI,KACXK,MAAO1I,KAAK0I,MACZC,OAAQ3I,KAAK2I,OAEhB,GAIL,MAAME,EAAUrJ,EAAmBsJ,wBACnC,IAAIV,EAAMS,EAAOT,IACbC,EAAOQ,EAAOR,KACdC,EAASO,EAAOP,OAChBE,EAAQK,EAAOL,OACfE,MAAEA,EAAKC,OAAEA,GAAWE,EAExB,IAAKb,GAA6BC,IAA8BzI,IAAOkI,OAAQ,CAC7ES,EAAYA,GAAe3I,EAAmB4G,WAE9C,GACE,GAAI+B,GAAWW,wBAA0D,SAAhClC,EAAIuB,EAAW,cAA4BF,GAA4D,WAA/BrB,EAAIuB,EAAW,aAA4B,CAC1J,MAAMY,EAAgBZ,EAAUW,wBAC1BE,EAAYC,SAASrC,EAAIuB,EAAW,sBAAkC,EACtEe,EAAaD,SAASrC,EAAIuB,EAAW,uBAAmC,EAE9EC,GAAOW,EAAcX,IAAMY,EAC3BX,GAAQU,EAAcV,KAAOa,EAC7BZ,EAASF,EAAMS,EAAOF,OACtBH,EAAQH,EAAOQ,EAAOH,MACtB,aAEMP,EAAYA,EAAU/B,YAGlC,GAAI8B,GAAa1I,IAAOkI,OAAQ,CAC9B,MAAMyB,EAAW9B,EAAOc,GAAc3I,GACtC,GAAI2J,EAAU,CACZ,MAAQC,EAAGC,EAAQC,EAAGC,GAAWJ,EACjCf,GAAOmB,EACPlB,GAAQgB,EACRX,GAASW,EACTV,GAAUY,EACVjB,EAASF,EAAMO,EACfH,EAAQH,EAAOK,GAInB,MAAO,CACLN,MACAC,OACAC,SACAE,QACAE,QACAC,SACArE,EAAG+D,EACH9D,EAAG6D,EACH,MAAAQ,GACE,MAAO,CACLtE,EAAGtE,KAAKsE,EACRC,EAAGvE,KAAKuE,EACR6D,IAAKpI,KAAKoI,IACVI,MAAOxI,KAAKwI,MACZF,OAAQtI,KAAKsI,OACbD,KAAMrI,KAAKqI,KACXK,MAAO1I,KAAK0I,MACZC,OAAQ3I,KAAK2I,OAEhB,EACS,EC/KP,MAAMa,EAAc,CAACC,EAAgBC,IACnCC,KAAKC,MAAMH,EAAMrB,OAASuB,KAAKC,MAAMF,EAAMtB,MAAQuB,KAAKC,MAAMH,EAAMpB,QAAUsB,KAAKC,MAAMF,EAAMrB,OAASsB,KAAKC,MAAMH,EAAMd,UAAYgB,KAAKC,MAAMF,EAAMf,SAAWgB,KAAKC,MAAMH,EAAMf,SAAWiB,KAAKC,MAAMF,EAAMhB,OAuB1MmB,EAAU,CAAC/E,EAAqBgF,EAAsBC,EAAiBC,EAAkBC,KACpG,IAAKD,EAAU,OAGfpD,EAAI9B,EAAQ,aAAc,IAC1B8B,EAAI9B,EAAQ,YAAa,IAGzB,MAAMqE,EAAW9B,EAAOvC,GAClBuE,EAASF,GAAUC,GAAK,EACxBG,EAASJ,GAAUG,GAAK,EAGxBY,GAAcJ,EAAYzB,KAAO0B,EAAO1B,MAAQgB,EAChDc,GAAcL,EAAY1B,IAAM2B,EAAO3B,KAAOmB,EAGpDzE,EAAOsF,aAAeF,EACtBpF,EAAOuF,aAAeF,EAGtBvD,EAAI9B,EAAQ,YAAa,eAAeoF,OAAgBC,UA1B9B,CAACrF,IAAgCA,EAAOwF,WAAW,EA6B7EC,CAAazF,GAGb8B,EAAI9B,EAAQ,aAAc,aAAakF,MAAaC,EAAQO,OAAS,IAAMP,EAAQO,OAAS,MAC5F5D,EAAI9B,EAAQ,YAAa,sBAGrBA,EAAO2F,UACTnK,aAAawE,EAAO2F,UAItB3F,EAAO2F,SAAW/C,OAAOgD,YAAW,KAClC9D,EAAI9B,EAAQ,aAAc,IAC1B8B,EAAI9B,EAAQ,YAAa,IACzBA,EAAO2F,UAAW,EAClB3F,EAAOsF,YAAa,EACpBtF,EAAOuF,YAAa,CAAK,GACxBL,EAA8B,QC7DtBW,EACHC,gBAAqC,GACrCC,oBACAlH,SACApC,MACAE,eACA7B,WAER,WAAAR,CAAYuE,GACV3D,KAAK2D,SAAWA,EAChB3D,KAAKuB,MAAQD,EAAcjC,cAC3BW,KAAKyB,eAAiBzC,EAAeK,cACrCW,KAAKJ,WAAayB,OAAO,yBAMpB,qBAAAyJ,GAEL,GADA9K,KAAK4K,gBAAkB,IAClB5K,KAAK2D,SAASsG,QAAQc,UAAW,OAEtC,MAAMC,EAAYhL,KAAKuB,MAAMiE,mBACZN,MAAMC,KAAKnF,KAAK2D,SAASnE,GAAG6F,UAEpCtE,SAASkK,IAChB,KAAMA,aAAiBlG,aAAc,OACrC,GAA8B,SAA1B6B,EAAIqE,EAAO,YAAyBA,IAAUD,EAAUhJ,QAAS,OAErE,MAAMT,EAAyB,CAC7BuD,OAAQmG,EACRC,KAAMnD,EAAQkD,IAGhBjL,KAAK4K,gBAAgBO,KAAK5J,GAG1B,MAAM6J,EAAW,IAAK7J,EAAM2J,MAGxBD,EAAMI,uBACRrL,KAAKsL,uBAAuBL,EAAOG,GAGrCH,EAAMG,SAAWA,CAAQ,IAOtB,iBAAAG,CAAkBhK,GACvBvB,KAAK4K,gBAAgBO,KAAK5J,GAMrB,oBAAAiK,CAAqB1G,GAC1B,MAAM2G,EChEM,SAAgCC,EAAUC,GACxD,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAIG,OAAQD,IAK9B,GAJgBpI,OAAOsI,KAAKH,GAAKI,OAAO5E,GAC/BwE,EAAIxE,KAAoBuE,EAAIE,GAAGzE,KAG3B,OAAOyE,EAEtB,OAAS,CACX,CDuDkBI,CAAchM,KAAK4K,gBAAiB,CAAE9F,YACtC,IAAV2G,GACFzL,KAAK4K,gBAAgBqB,OAAOR,EAAO,GAOhC,UAAAS,CAAWC,GAChB,IAAKnM,KAAK2D,SAASsG,QAAQc,UAEzB,YADA/K,KAAKoM,eAAeD,GAItB,MAAME,UAAEA,EAASC,YAAEA,GAAgBtM,KAAKuM,yBAExCvM,KAAKwM,iBAAiBH,EAAWC,EAAaH,GAC9CnM,KAAK4K,gBAAkB,GAMlB,OAAAf,CAAQ/E,EAAqBgF,EAAsBC,EAAiBC,GACzEyC,EAAe3H,EAAQgF,EAAaC,EAAQC,EAAUhK,KAAK2D,SAASsG,SAU9D,sBAAAqB,CAAuBzL,EAAsBqL,GACnD,MAAMwB,EAAyB1F,iBAAiBnH,GAAS2H,UACzD,GAAIkF,GAAqC,SAAnBA,EAA2B,CAC/C,MAAMrF,EAAoB,IAAIM,UAAU+E,GAExC,OAAO,IAAIC,QACTzB,EAAK5G,EAAI+C,EAAOuF,IAChB1B,EAAK3G,EAAI8C,EAAOwF,IAChB3B,EAAKxC,MACLwC,EAAKvC,QAGT,OAAOuC,EAMD,sBAAAqB,GACN,IAAIF,GAAY,EACZC,EAAc,EAWlB,OATAtM,KAAK4K,gBAAgB7J,SAASQ,IAC5B,MAAMyI,EAAWhK,KAAK8M,2BAA2BvL,GAC7CyI,IACFqC,GAAY,EACZC,EAAc3C,KAAKoD,IAAIT,EAAatC,GACpChK,KAAKgN,oBAAoBzL,EAAMuD,OAAQkF,OAIpC,CAAEqC,YAAWC,eAWd,0BAAAQ,CAA2BvL,GACjC,MAAMuD,OAAEA,GAAWvD,EACbuI,EAAuB/B,EAAQjD,GACrC,IAAIkF,EAAmB,EAoBvB,OAjBIlF,EAAOuG,uBAAyBvG,EAAOmI,cAAgBnI,EAAOoI,YAAc1D,EAAY1E,EAAOmI,aAAcnD,KAC/GE,ED7I2B,EAACmD,EAAwB/B,EAAmBrB,EAAiBE,KAC5F,MAAMmD,EAAMzD,KAAK0D,IAAIjC,EAAShD,IAAM+E,EAAc/E,IAAK,GACjDkF,EAAM3D,KAAK0D,IAAIjC,EAAS/C,KAAO8E,EAAc9E,KAAM,GACnDkF,EAAM5D,KAAK0D,IAAIjC,EAAShD,IAAM2B,EAAO3B,IAAK,GAC1CoF,EAAM7D,KAAK0D,IAAIjC,EAAS/C,KAAO0B,EAAO1B,KAAM,GAElD,OAAQsB,KAAK8D,KAAKL,EAAME,GAAO3D,KAAK8D,KAAKF,EAAMC,IAASvD,EAAQc,WAAa,EAAE,ECuIhE2C,CAAkBnM,EAAM2J,KAAMpG,EAAOmI,aAAcnI,EAAOoI,WAAYlN,KAAK2D,SAASsG,UAI7FnF,EAAOsG,WAAa5B,EAAYM,EAAahF,EAAOsG,YAEtDpL,KAAK2N,wBAAwB7I,EAAQgF,GAGhCE,IACHA,EAAWhK,KAAK2D,SAASsG,QAAQc,WAAa,GAGhD/K,KAAK6J,QAAQ/E,EAAQvD,EAAM2J,KAAMpB,EAAaE,IAGzCA,EAaD,uBAAA2D,CAAwB7I,EAAqBgF,GACnDhF,EAAOmI,aAAenI,EAAOsG,SAC7BtG,EAAOoI,WAAapD,EAMd,mBAAAkD,CAAoBlI,EAAqBkF,GAC3ClF,EAAO8I,qBACTtN,aAAawE,EAAO8I,qBAGtB9I,EAAO8I,oBAAsBlG,OAAOgD,YAAW,KAC7C5F,EAAO+I,cAAgB,EACvB/I,EAAOmI,aAAe,KACtBnI,EAAOsG,SAAW,KAClBtG,EAAOoI,WAAa,KACpBpI,EAAOuG,sBAAwB,KAC/BvG,EAAO8I,yBAAsB7G,CAAS,GACrCiD,GAGHhK,KAAKyB,eAAerB,cAAcJ,KAAKJ,WAAYkF,EAAO8I,qBAC1D9I,EAAOuG,sBAAwBrB,EAMzB,gBAAAwC,CAAiBH,EAAoBrC,EAAkBmC,GACzDnM,KAAK6K,qBACPvK,aAAaN,KAAK6K,qBAGfwB,GAKLrM,KAAK6K,oBAAsBnD,OAAOgD,YAAW,KAC3CyB,MACAnM,KAAK6K,yBAAsB9D,CAAS,GACnCiD,GAGChK,KAAK6K,qBACP7K,KAAKyB,eAAerB,cAAcJ,KAAKJ,WAAYI,KAAK6K,sBAXxDsB,MAkBI,cAAAC,CAAeD,GACrB7L,aAAaN,KAAK6K,qBAClBsB,MAGK,OAAA2B,GAEL9N,KAAKyB,eAAetB,QAAQH,KAAKJ,aE7O/B,SAAUmO,EAAkBlO,GAEhC,MAGMmO,EAHuB,CAACnO,EAAQoO,SAAW,GAAIpO,EAAQqO,WAAa,GAAKrO,EAA6BsO,KAAO,GAAKtO,EAA8BuO,MAAQ,GAAIvO,EAAQwO,aAAe,IAGlKC,KAAK,KAC5B,IAAIC,EAAO,EAEX,IAAK,IAAI3C,EAAI,EAAGA,EAAIoC,EAAInC,OAAQD,IAAK,CAEnC2C,GAAQA,GAAQ,GAAKA,EADRP,EAAIQ,WAAW5C,GAE5B2C,GAAOA,EAGT,OAAO5E,KAAK8E,IAAIF,GAAMG,SAAS,GACjC,CCLO,MAAMC,EAAkB,CAACnP,EAAiBoP,GAAyB,KACxE,IAAInK,EAGJ,IAAKjF,IAAOA,EAAG4F,cACb,OAAO,KAGT,IAAIyJ,EAA6BrP,EAAG4F,cAEpC,KAAOyJ,GAAQ,CACbpK,EAAQiD,OAAOV,iBAAiB6H,GAChC,MAAMC,EAAWrK,EAAMqK,SAAWrK,EAAMsK,UAAYtK,EAAMuK,UAG1D,GAAI,sBAAsBC,KAAKH,IAAcF,GAAiBE,EAASI,SAAS,UAC9E,OAAOL,EAGTA,EAASA,EAAOzJ,cAIlB,OAAQT,SAASwK,kBAAoCxK,SAASyK,eAAe,QC7BlEC,EACHlQ,sBAA0C,CAChDmQ,MAAO,KACPC,MAAM,EACNC,UAAU,EACVC,MAAO,KACPC,OAAQ,KACRC,UAAW,KACXC,cAAe,EACfC,YAAY,EACZC,sBAAuB,KACvBC,mBAAmB,EACnBC,UAAW,WACXC,cAAe,oBACfC,YAAa,kBACbC,UAAW,gBACXC,OAAQ,SACRC,OAAQ,KACRC,iBAAiB,EACjBvF,UAAW,EACXP,OAAQ,KACR+F,QAAS,SAAUC,EAA4BC,GAC7CD,EAAaD,QAAQ,OAAQE,EAASpC,aAAe,GACtD,EACDqC,YAAY,EACZC,gBAAgB,EAChBC,WAAY,UACZC,MAAO,EACPC,oBAAqB,EACrBC,eAAe,EACfC,cAAe,oBACfC,gBAAgB,EAChBC,kBAAmB,EACnBC,eAAgB,CAAE7M,EAAG,EAAGC,EAAG,GAC3B6M,gBAAgB,EAChBC,qBAAsB,GAGP9P,MACA3B,WACA6B,eACT6P,iBACAC,eACAC,gBAAyC,KAE1CvH,QACAzK,GAEP,WAAAJ,CAAYI,EAAiByK,GAC3B,IAAKzK,IAAOA,EAAG2G,UAA4B,IAAhB3G,EAAG2G,SAC5B,MAAM,IAAInD,MAAM,6DAGlBhD,KAAKJ,WAAayB,OAAO,oBACzBrB,KAAKyB,eAAiBzC,EAAeK,cACrCW,KAAKR,GAAKA,EACVQ,KAAKiK,QAAU,IAAKoF,EAASoC,kBAAmBxH,GAChDjK,KAAKuB,MAAQD,EAAcjC,cAG3BW,KAAKsR,iBAAmB,IAAI3G,EAAsB3K,MAClDA,KAAKyB,eAAelB,yBAAyBP,KAAKJ,YAAY,KAC5DI,KAAKsR,iBAAiBxD,SAAS,IAIjC9N,KAAKuB,MAAMwB,iBAAiBvD,EAAIQ,MAGhCA,KAAK0R,2BAGD1R,KAAKiK,QAAQqF,OACftP,KAAK2R,eAID,wBAAAD,GACN,MAAME,EAAgDxT,IACpD4B,KAAK6R,WAAWzT,EAAI,EAIlB4B,KAAKiK,QAAQmH,eACfpR,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAYI,KAAKR,GAAI,cAAeoS,IAEnF5R,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAYI,KAAKR,GAAI,YAAaoS,GACjF5R,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAYI,KAAKR,GAAI,aAAcoS,IAIpF,MAAME,EAAWnD,EAAgB3O,KAAKR,IACtC,GAAIsS,GAAYA,IAAanN,SAASyK,iBAAmB0C,IAAanN,SAASwK,iBAAkB,CAC/F,MAAM4C,EAA4C3T,IAChD4B,KAAKgS,SAAS5T,EAAI,EAGpB4B,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAYkS,EAAU,SAAUC,IAK3EE,OAAS,CAACC,EAAmBC,EAAqBnC,EAA8BoC,KACtF,MAAMnI,EAAUjK,KAAKiK,QACfoI,EAAYpI,EAAQ2F,eAAiB,EACrCC,EAAa5F,EAAQ4F,aAAc,EACnCyC,EAAoBrI,EAAQ6F,uBAAyBuC,EAErDE,GAAQ1C,GAAkCwC,EAAY,GACtDrH,EAAYhL,KAAKuB,MAAMiE,mBAE7B,GAAkB,aAAdwK,EAA0B,CAC5B,MAAMwC,EAAaN,EAAS9J,IAAM8J,EAASvJ,OAAS,EAC9C8J,EAAeN,EAAW/J,IAAM+J,EAAWxJ,OAAS,EAG1D,GAFwB4J,GAASC,EAAaC,GAAgBN,EAAWxJ,OAAS0J,GAAaI,EAAeD,GAAcL,EAAWxJ,OAAS2J,EAG9I,OAAOtS,KAAK0S,kBAAkBN,EAASpH,EAAUlJ,SAAUyQ,OAExD,CACL,MAAMC,EAAaN,EAAS7J,KAAO6J,EAASxJ,MAAQ,EAC9C+J,EAAeN,EAAW9J,KAAO8J,EAAWzJ,MAAQ,EAG1D,GAFwB6J,GAASC,EAAaC,GAAgBN,EAAWzJ,MAAQ2J,GAAaI,EAAeD,GAAcL,EAAWzJ,MAAQ4J,EAG5I,OAAOtS,KAAK0S,kBAAkBN,EAASpH,EAAUlJ,SAAUyQ,GAI/D,OAAO,CAAK,EAGN,iBAAAG,CAAkB5N,EAA4B6N,EAA6BC,GACjF,IAAK9N,IAAW6N,EAAS,OAAO,EAEhC,MAAME,EAAY,IAAIC,YAAY,gBAAiB,CACjDC,SAAS,EACTC,YAAY,EACZC,OAAQ,CACNnO,SACA6N,UACAC,qBAKJ,OADA5S,KAAKR,GAAG0T,cAAcL,IACdA,EAAUM,iBAIZtB,WAAczT,IACpB,IAAKA,EAAI4U,WAAY,OAErB,MAAMlO,EAAS9E,KAAKuB,MAAMsD,eAAezG,GACzC,IAAK0G,EAAQ,OAEb,MAAMsO,EAAc/M,EAAQvB,EAAQ9E,KAAKqT,uBAAwBrT,KAAKR,IAAI,GAC1E,IAAK4T,EAAa,OAGlB,MAAME,EAAc7U,EAAoBL,GACxC,IAAKkV,EAAa,OAElB,MAAM3U,QAAEA,EAAOC,QAAEA,GAAY0U,EAG7BtT,KAAKuB,MAAMmC,UAAU0P,EAAazU,EAASC,GAG3C,MAAMF,EAAQP,EAAkBC,GAC5BM,GACFsB,KAAKuB,MAAMsC,mBAAmBnF,EAAMC,QAASD,EAAME,SAGrDoB,KAAKuT,wBAAwB7U,EAAO0U,EAAY,EAG1CI,SAAW,KACjB,MAAMxI,EAAYhL,KAAKuB,MAAMiE,mBAC7B,IAAKwF,EAAUlJ,SAAU,OAGzB9B,KAAKyT,mBAGL,MAAMC,EAAgB1T,KAAKR,GAAGkU,cAC1B1T,KAAKiK,QAAQmH,eACfpR,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAY8T,EAAe,cAAe1T,KAAK2T,gBAE9F3T,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAY8T,EAAe,YAAa1T,KAAK2T,eAC5F3T,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAY8T,EAAe,YAAa1T,KAAK2T,gBAE9F3T,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAY8T,EAAe,WAAY1T,KAAK4T,YAG3F5T,KAAKuB,MAAMwC,mBAAmB,CAC5BhC,OAAQiJ,EAAUlJ,SAClBO,SAAU6C,MAAMC,KAAKnF,KAAKR,GAAG6F,UAAUC,QAAQ0F,EAAUlJ,YAE3D9B,KAAK6T,kBAAkB,YAAY,EAG7B,uBAAAN,CAAwB7U,EAAoCoG,GAClEA,EAAOL,MAAMqP,WAAa,YAC1B9T,KAAK+T,oBAAoBrV,GAGzB,MAAMmS,EAAS7Q,KAAKiK,QAA6B4G,MAE7C7Q,KAAKgU,oBACPhU,KAAKuR,eAAiB7J,OAAOgD,YAAW,KACtC1K,KAAKwT,WACLxT,KAAKuR,oBAAiBxK,CAAS,GAC9B8J,GAGH7Q,KAAKyB,eAAerB,cAAcJ,KAAKJ,WAAYI,KAAKuR,iBAExDvR,KAAKwT,WAKDG,cAAiBvV,IACvB,MAAM4M,EAAYhL,KAAKuB,MAAMiE,mBAC7B,IAAKwF,EAAUnJ,SAAWzD,EAAI4U,WAAY,OAE1C,MAAMM,EAAc7U,EAAoBL,GACxC,IAAKkV,EAAa,OAElB,MAAM3U,QAAEA,EAAOC,QAAEA,GAAY0U,EAK7B,GAFAtT,KAAKuB,MAAMsC,mBAAmBlF,EAASC,GAEnCoM,EAAUjJ,OAAQ,CACpB3D,EAAI6V,iBACJjU,KAAKkU,gBAAgB9V,GAGrB,MAAM+V,EAAM9M,EAAO2D,EAAUjJ,SAAW,CAAEqS,EAAG,EAAGC,EAAG,GAC7CxR,EAAKlE,EAAUqM,EAAUtI,SAAS/D,QAClCmE,EAAKlE,EAAUoM,EAAUtI,SAAS9D,QAExCoM,EAAUjJ,OAAO0C,MAAM+C,UAAY,eAAe3E,GAAMsR,EAAIC,GAAK,QAAQtR,GAAMqR,EAAIE,GAAK,eACnF,IAAKrJ,EAAUvI,MAAO,CAC3B,MAAM4P,EAAarS,KAAKiK,QAA6B6G,qBAAuB,EACvDnH,KAAKoD,IAAIpD,KAAK8E,IAAI9P,EAAUqM,EAAUtI,SAAS/D,SAAUgL,KAAK8E,IAAI7P,EAAUoM,EAAUtI,SAAS9D,WAEhGyT,IAClBrS,KAAKuB,MAAMwC,mBAAmB,CAAEtB,OAAO,IACvCzC,KAAKwT,cAKHI,WAAcxV,IACpB,MAAM4M,EAAYhL,KAAKuB,MAAMiE,mBAC7B,IAAKwF,EAAUnJ,SAAWmJ,EAAUlJ,SAAU,OAK9C,IAAInD,EACAC,EAGJ,GAPAR,EAAI6V,iBACJ7V,EAAIkW,kBAMAtU,KAAK3B,aAAaD,GAAM,CAC1B,MAAMM,EAAQN,EAAIE,QAAQ,GAC1B,IAAKI,EAAO,OACZC,EAAUD,EAAMC,QAChBC,EAAUF,EAAME,aACPoB,KAAKuU,YAAYnW,GAC1BO,EAAUP,EAAIO,QACdC,EAAUR,EAAIQ,QAOhB,MAAM4V,EAAW7P,SAASC,iBAAiBjG,EAASC,GACpD,IAAK4V,EAAU,OAEf,MAAMpB,EAAc/M,EAAQmO,EAAUxU,KAAKqT,uBAAwBrT,KAAKR,IAAI,GAC5E,IAAK4T,GAAeA,IAAgBpI,EAAUlJ,SAAU,OAExD,MAAMoJ,EAAOnD,EAAQqL,GACfpD,EAAYhQ,KAAKyU,aAAarW,EAAKgV,GAGnCsB,EAActB,EAAYuB,uBAC1BC,EAAcxB,EAAYyB,mBAG1BC,EAAU5J,EAAK9C,IAAM8C,EAAKvC,OAAS,EACnCoM,EAAU7J,EAAK7C,KAAO6C,EAAKxC,MAAQ,EACnCsM,EAA2B,aAAdhF,EAKbiF,GAJaD,EAAapW,EAAUD,IAC3BqW,EAAaF,EAAUC,GAIhC3C,EAAU6C,EAAeP,EAAcE,EAGvC1C,EAAWnK,EAAQiD,EAAUlJ,UAGnC,GAAI9B,KAAKiS,OAAOC,EAAUhH,EAAM8E,EAAWoC,GAAU,CAEnDpS,KAAK8K,wBAGDmK,EACF7B,EAAYhN,YAAY6O,aAAajK,EAAUlJ,SAAUsR,GAEzDA,EAAYhN,YAAY6O,aAAajK,EAAUlJ,SAAUsR,EAAYwB,aAIvE5U,KAAKuL,kBAAkB,CACrBzG,OAAQsO,EACRlI,KAAMnD,EAAQqL,KAIhBpT,KAAKuB,MAAMsC,mBAAmBlF,EAASC,GAGvC,MAAMyD,EAAW2I,EAAU3I,WAAc,EACnCC,EAAW4C,MAAMC,KAAKnF,KAAKR,GAAG6F,UAAUC,QAAQ0F,EAAUlJ,UAE5DO,IAAaC,GACftC,KAAK6T,kBAAkB,OAAQ,CAC7BxR,WACAC,WACAP,OAAQiJ,EAAUlJ,SAClBgD,OAAQsO,IAKPpT,KAAKiK,QAA6Bc,WACrC/K,KAAKkM,eAKH8F,SAAY5T,IAClB,MAAM4M,EAAYhL,KAAKuB,MAAMiE,mBAC7B,IAAKwF,EAAUnJ,SAAWmJ,EAAUjJ,OAAQ,OAG5C,MAAMoC,UAAEA,EAASC,WAAEA,GAAehG,EAAI0G,OAGhCqP,EAAM9M,EAAO2D,EAAUjJ,SAAW,CAAEqS,EAAG,EAAGC,EAAG,GAC7CxR,EAAKmI,EAAUtI,SAAS/D,QAAUqM,EAAUtI,SAASC,SACrDG,EAAKkI,EAAUtI,SAAS9D,QAAUoM,EAAUtI,SAASE,SAE3DoI,EAAUjJ,OAAO0C,MAAM+C,UAAY,eAAe3E,GAAMsR,EAAIC,GAAK,QAAQtR,GAAMqR,EAAIE,GAAK,UAGxFrU,KAAKuB,MAAM2C,qBAAqBC,EAAWC,EAAW,EAGhD8P,gBAAmB9V,IAEzB,MAAM4M,EAAYhL,KAAKuB,MAAMiE,mBAC7B,IAAKwF,EAAUnJ,SAAWmJ,EAAUjJ,OAAQ,OAG5C,MAAMuR,EAAc7U,EAAoBL,GACxC,IAAKkV,EAAa,OAElB,MAAM3U,QAAEA,EAAOC,QAAEA,GAAY0U,EAG7BtT,KAAKkV,4BAA2B,GAGhC,MAAMC,EAAgBxQ,SAASC,iBAAiBjG,EAASC,GACzD,KAAKuW,GAAmBA,aAAyBpQ,aAE/C,YADA/E,KAAKkV,4BAA2B,GAQlC,GAHAlV,KAAKkV,4BAA2B,GAG5BlV,KAAKoV,gBAAgBD,GAAgB,CACvC,MAAME,EAAiBrV,KAAKsV,kBAAkBH,GAC9C,GAAIE,GAAkBA,IAAmBrV,KAEvC,YADAqV,EAAeE,eAAenX,GAMlC,MAAMgV,EAAc/M,EAAQ8O,EAAenV,KAAKqT,uBAAwBrT,KAAKR,IAAI,GACjF,IAAK4T,GAAeA,IAAgBpI,EAAUlJ,SAAU,OAGxD,MAAMoQ,EAAWnK,EAAQiD,EAAUjJ,QAC7BoQ,EAAapK,EAAQqL,GACrBpD,EAAYhQ,KAAKyU,aAAarW,EAAKgV,GAGnChB,EAAUpS,KAAKwV,iBAAiBpC,EAAapD,GAG/ChQ,KAAKiS,OAAOC,EAAUC,EAAYnC,EAAWoC,KAC/CpS,KAAK8K,wBACL9K,KAAKyV,SAASrC,GACdpT,KAAKuL,kBAAkB,CACrBzG,OAAQsO,EACRlI,KAAMnD,EAAQqL,OAKZsC,OAAUtX,IACZA,GACFA,EAAI6V,iBAGN,MAAMjJ,EAAYhL,KAAKuB,MAAMiE,mBAC7B,IAAKwF,EAAUnJ,SAAWmJ,EAAUjJ,OAAQ,OAGxCiJ,EAAUjJ,OAAOqE,YACnB4E,EAAUjJ,OAAOqE,WAAWuP,YAAY3K,EAAUjJ,QAIpD,MAAMkO,EAAiBjQ,KAAKiK,QAA6BgG,eAAiB,oBACpEe,EAAiBhR,KAAKiK,QAA6B+G,eAAiB,oBAEtEhG,EAAUlJ,WACZ2E,EAAYuE,EAAUlJ,SAAUmO,GAAe,GAC/CxJ,EAAYuE,EAAUlJ,SAAUkP,GAAe,IAIjDhR,KAAK6T,kBAAkB,QAGvB7T,KAAKuB,MAAM0C,SAAS,EAId,gBAAAuR,CAAiB1Q,EAAqBkL,GAC5C,MAAqB,aAAdA,EAA4BlL,EAAO+P,mBAA6C/P,EAAO6P,uBAGxFW,kBAAqB9V,IAC3B,IAAIgH,EAA8BhH,EAElC,KAAOgH,GAAWA,IAAY7B,SAASiR,MAAM,CAC3C,MAAMtW,EAAWU,KAAKuB,MAAMlC,YAAYmH,GACxC,GAAIlH,EAAU,OAAOA,EACrBkH,EAAUA,EAAQpB,cAGpB,OAAO,IAAI,EAGL,0BAAA8P,CAA2BW,GACjC,MAAM7K,EAAYhL,KAAKuB,MAAMiE,mBACzBwF,EAAUjJ,QACZ6E,EAAIoE,EAAUjJ,OAAQ,UAAW8T,EAAO,GAAK,QAIzC,gBAAApC,GACN,MAAMzI,EAAiChL,KAAKuB,MAAMiE,mBAClD,IAAKwF,EAAUlJ,SAAU,OAGzB,MAAMqG,EAA0BnI,KAAKiK,QAA6BgH,eAAiBtM,SAASiR,KAAO5V,KAAKR,GAClGsW,EAAmCnH,EAAgB3O,KAAKR,IACxDuW,GAAkCD,GAAgBA,IAAiBnR,SAASiR,QAAS,EAGrF1K,EAAgBnD,EAAQiD,EAAUlJ,UAAU,EAAO9B,KAAKiK,QAA6BgH,gBAAgB,EAAM9I,GAG3GpG,EAAsB/B,KAAKgW,kBAAkBhL,EAAUlJ,SAAUoJ,GAGvElL,KAAKiW,oBAAoBlU,EAAQmJ,EAAM6K,EAAuBD,GAG9D3N,EAAU+N,YAAYnU,GACtB/B,KAAKuB,MAAMwC,mBAAmB,CAAEhC,WAG1B,iBAAAiU,CAAkBlU,EAAuBoJ,GAC/C,MAAMnJ,EAAsBD,EAASqU,WAAU,IACzClG,cAAEA,EAAgB,oBAAmBe,cAAEA,EAAgB,qBAAwBhR,KAAKiK,QAG1FxD,EAAY1E,EAAQiP,GAAe,GACnCvK,EAAY1E,EAAQkO,GAAe,GAGnC,MAAMmG,EAAqC,CACzC1T,SAAU,QACV2T,OAAQ,SACRC,cAAe,OACf5N,MAAO,GAAGwC,EAAKxC,UACfC,OAAQ,GAAGuC,EAAKvC,WAChB4N,UAAW,aACXC,OAAQ,IACRC,QAAS,MACTC,WAAY,GACZlP,UAAW,IAIb,OADAZ,EAAI7E,EAAQqU,GACLrU,EAGD,mBAAAkU,CAAoBlU,EAAqBmJ,EAAe6K,EAAgCD,GAC9F,IAAKC,EAKH,YAJAnP,EAAI7E,EAAQ,CACVqG,IAAK,GAAG8C,EAAK9C,QACbC,KAAM,GAAG6C,EAAK7C,WAMlB,MAAMsO,EAA4B5O,EAAQ+N,GACpCc,GDtegBpX,ECse8CsW,KDre3DpO,OACF,CACLvD,UAAWuD,OAAOmP,aAAelS,SAASyK,gBAAgBjL,UAC1DC,WAAYsD,OAAOoP,aAAenS,SAASyK,gBAAgBhL,YAIxD,CACLD,UAAY3E,EAAmB2E,UAC/BC,WAAa5E,EAAmB4E,YAVX,IAAC5E,ECwetBoH,EAAI7E,EAAQ,CACVW,SAAU,WACV0F,IAAK,GAAG8C,EAAK9C,IAAMuO,EAAiBvO,IAAMwO,EAAOzS,cACjDkE,KAAM,GAAG6C,EAAK7C,KAAOsO,EAAiBtO,KAAOuO,EAAOxS,iBAKhD,YAAA/F,CAAaD,GACnB,MAAO,YAAaA,EAGd,WAAAmW,CAAYnW,GAClB,MAAO,iBAAkBA,EAGnB,gBAAA4V,GACN,SAAUhU,KAAKiK,QAAQ4G,OAAS7Q,KAAKiK,QAAQ4G,MAAQ,GAG/C,iBAAAkD,CAAkBgD,GACxB,MAAMC,EAAMhX,KAAKR,GAAGkU,cAEf1T,KAAKiK,QAA6BmH,gBACrCpR,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAYoX,EAAK,cAAehX,KAAK2T,eACpF3T,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAYoX,EAAK,YAAahX,KAAK0V,QAClF1V,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAYoX,EAAK,gBAAiBhX,KAAK0V,UAEtF1V,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAYoX,EAAKD,EAAU,YAAc,YAAa/W,KAAK2T,eAC1G3T,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAYoX,EAAKD,EAAU,WAAa,UAAW/W,KAAK0V,QACnGqB,GACF/W,KAAKyB,eAAe9B,sBAAsBK,KAAKJ,WAAYoX,EAAK,cAAehX,KAAK0V,SAKlF,QAAAD,CAAS3Q,GACf,MAAMkG,EAAYhL,KAAKuB,MAAMiE,mBAC7B,IAAKwF,EAAUlJ,SAAU,OAEzB,MAAMO,EAAW6C,MAAMC,KAAKnF,KAAKR,GAAG6F,UAAUC,QAAQ0F,EAAUlJ,UAC1DQ,EAAW4C,MAAMC,KAAKnF,KAAKR,GAAG6F,UAAUC,QAAQR,GAElDzC,IAAaC,IACftC,KAAKR,GAAGyV,aAAajK,EAAUlJ,SAAUgD,GACzC9E,KAAK6T,kBAAkB,OAAQ,CAC7BxR,WACAC,WACAP,OAAQiJ,EAAUlJ,SAClBgD,YAKE,iBAAA+O,CAAkBnN,EAAcuM,EAA8B,IACpE,MAAM7U,EAAM,IAAI0U,YAAYpM,EAAM,CAChCqM,SAAS,EACTC,YAAY,EACZC,OAAQ,IACHA,EACH9N,KAAMnF,KAAKR,MAIfQ,KAAKR,GAAG0T,cAAc9U,GAGhB,YAAAqW,CAAarW,EAAY0G,GAC/B,MAAMkL,EAAYhQ,KAAKiK,QAAQ+F,UAC/B,MAAyB,mBAAdA,EACFA,EAAUiH,KAAKjX,KAAM5B,EAAK0G,EAAQ9E,KAAKuB,MAAMiE,mBAAmB1D,UAElEkO,GAAa,WAGd,eAAAoF,CAAgBtQ,GACtB,OAAQA,IAAY9E,KAAKR,GAAG0X,SAASpS,IAAWA,IAAW9E,KAAKR,GAG3D,OAAAsO,GACL9N,KAAKuB,MAAM2B,gBAAgBlD,KAAKJ,YAG3B,MAAAuX,CAAyCzQ,EAASU,GACvD,YAAcL,IAAVK,EACKpH,KAAKiK,QAAQvD,IAGtB1G,KAAKiK,QAAQvD,GAAQU,EACR,UAATV,GACF1G,KAAK2R,eAEAvK,GAGF,OAAAgQ,GACL,gBFtmB6BjP,EAAwBkP,EAA2BzG,GAClF,MAAM0G,EAAkB,GAClBjS,EAAW8C,EAAU9C,SAE3B,IAAK,IAAIuG,EAAI,EAAGA,EAAIvG,EAASwG,OAAQD,IAAK,CACxC,MAAMpM,EAAK6F,EAASuG,GAChBvF,EAAQ7G,EAAI6X,EAAmBlP,GAAW,IAC5CmP,EAAMnM,KAAK3L,EAAG+X,aAAa3G,IAAe7C,EAAkBvO,IAIhE,OAAO8X,CACT,CE0lBWE,CAAiBxX,KAAKR,GAAIQ,KAAKqT,uBAAyBrT,KAAKiK,QAA6B2G,YAAc,WAG1G,IAAArB,CAAK+H,EAAiBG,GAC3B,MAAMC,EAAwC,CAAE,EAC1CC,EAAS3X,KAAKR,GAEpBQ,KAAKoX,UAAUrW,SAAQ,CAAC6W,EAAIhM,KAC1B,MAAMpM,EAAKmY,EAAOtS,SAASuG,GACvBvF,EAAQ7G,EAAIQ,KAAKqT,uBAAwBsE,GAAQ,KACnDD,EAAME,GAAMpY,MAIhBiY,GAAgBzX,KAAK8K,wBAErBwM,EAAMvW,SAAS6W,IACTF,EAAME,KACRD,EAAOhC,YAAY+B,EAAME,IACzBD,EAAOzB,YAAYwB,EAAME,QAI7BH,GAAgBzX,KAAKkM,aAIhB,IAAA2L,GACL,MAAMpI,EAASzP,KAAKiK,QAA6BwF,MACjDA,GAAO9O,MAAMX,MAIR,qBAAA8K,GACL9K,KAAKsR,iBAAiBxG,wBAGjB,iBAAAS,CAAkBhK,GACvBvB,KAAKsR,iBAAiB/F,kBAAkBhK,GAGnC,oBAAAiK,CAAqB1G,GAC1B9E,KAAKsR,iBAAiB9F,qBAAqB1G,GAGtC,UAAAoH,CAAWC,GAChBnM,KAAKsR,iBAAiBpF,WAAWC,GAG5B,OAAAtC,CAAQ/E,EAAqBgF,EAAsBC,EAAiBC,GACzEhK,KAAKsR,iBAAiBzH,QAAQ/E,EAAQgF,EAAaC,EAAQC,GAGtD,cAAAuL,CAAenX,GACpB4B,KAAK4T,WAAWxV,GAGV,oBAAAiV,GACN,OAAQrT,KAAKiK,QAA6B0F,UAGpC,YAAAgC,GACN,MAAM1H,EAAUjK,KAAKiK,QAEhBA,EAAQqF,QACXrF,EAAQqF,MAAQ,CACd5I,UAAMK,EACN+Q,MAAM,EACNC,KAAK,EACLC,aAAa,IAIY,iBAAlB/N,EAAQqF,QACjBrF,EAAQqF,MAAQ,CAAE5I,KAAMuD,EAAQqF,QAGlC,MAAMA,EAAQrF,EAAQqF,MAOtBtP,KAAKwR,gBAAkB,CACrB9K,KAAM4I,EAAM5I,MAAQ,KACpBuR,UAAW,CAACC,EAAe/S,EAAiBpD,EAAqB3D,MAC1DkR,EAAMwI,OACe,mBAAfxI,EAAMwI,KACRxI,EAAMwI,KAAKI,EAAI/S,EAAMpD,EAAQ3D,GAE/BkR,EAAMwI,MAEfK,SAAU,CAACD,EAAe/S,EAAiBpD,EAAqB3D,KAC9D,IAAKkR,EAAMyI,IAAK,OAAO,EACvB,GAAI7S,MAAMkT,QAAQ9I,EAAMyI,KAAM,CAC5B,MAAMM,EAAalT,EAAkBqM,gBACrC,OAAOlC,EAAMyI,IAAI7I,SAASmJ,GAAW3R,MAAQ,IAE/C,MAAyB,mBAAd4I,EAAMyI,IACRzI,EAAMyI,IAAIG,EAAI/S,EAAMpD,EAAQ3D,KAE5BkR,EAAMyI,GAAG,EAEpBC,YAAa1I,EAAM0I,cAAe,GAIpChY,KAAKyB,eAAejB,sBAAsBR,KAAKJ,YAAY,KACzDI,KAAKwR,gBAAkB,IAAI"}